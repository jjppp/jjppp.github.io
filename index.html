<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Young, Simple &amp; Naive">
<meta property="og:type" content="website">
<meta property="og:title" content="jjppp">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="jjppp">
<meta property="og:description" content="Young, Simple &amp; Naive">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jpwang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>jjppp</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">jjppp</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog of jjppp</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jpwang</p>
  <div class="site-description" itemprop="description">Young, Simple & Naive</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/19/hello_world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/19/hello_world/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-19 09:33:01" itemprop="dateCreated datePublished" datetime="2022-06-19T09:33:01+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><pre><code class="cpp">void hello_world() &#123;
  std:: cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std:: endl;
&#125;
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%957-%E7%94%B5%E9%98%BB%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%957-%E7%94%B5%E9%98%BB%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算方法7 电阻网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-15 14:21:00" itemprop="dateCreated datePublished" datetime="2022-06-15T14:21:00+08:00">2022-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:47:11" itemprop="dateModified" datetime="2022-06-19T09:47:11+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          越发觉得自己物理学得烂了...

# 前置

前置的物理定律包括如下两条：

1. 欧姆定律，即 $\phi_i-\phi_j=U_{i,j}=I_{i,j}R$。定义电导率为 $w=R^{-1}$，那么有 $I_{i,j}=U_{i,j}w$。
2. 基尔霍夫定律，即对于电阻网络的任意节点 $v$，流入的电流等于流出的电流 。

# 电路网络与 $L$

对于单位电阻组成的电路网络 $G$，其拉普拉斯矩阵 $L$ 可以通过上面两条物理定律和电流联系起来。

考虑电路网络内部的节点 $x$，根据基尔霍夫定律有
$$
b_x=\sum_{y\in N(x)} I_{x,y}=\sum_{y\in N(x)} (\phi_x-\phi_y)w
$$
为了方便讨论，一般会规定电源电势为 $1V$，或流入电路网络的电流总量为 $1A$，此处采用第二个约定。

对于单位电阻有 $w=1$，此时上述方程组可以写成 
$$
L\phi=b
$$
其中 $b_x$ 表示流入 $x$ 的电流（流入为正，流出为负）。将电源接在图上任意两点间（不妨设为 $s,tttt$），其含义为向量 $b$ 满足 $b_s=1,b_t=-1$，其余均为 $0$。



再考虑欧姆定律，有
$$
B^\intercal \phi=I
$$
其中 $B$ 为图 $G$ 的 $n\times m$ 关联矩阵，形如 $\begin{bmatrix}\cdots&\cdots&\cdots \\ \cdots& 1& \cdots \\ \cdots&\cdots&\cdots \\ \cdots& -1& \cdots\\\cdots&\cdots&\cdots\end{bmatrix}$，第 $i$ 列表示边 $e_i$ 关联哪两条边，正负表示方向。$m$ 维向量 $I$ 表示每条边上电流的流量。



如果要考虑非单位电阻的矩阵，那么需要引入 $m\times m$ 的对角阵 $W=\text{diag}\set{w_{e_1},w_{e_2}\ldots w_{e_m} }$ 来分别建模每条边的电导率，在需要的时候乘上就行了。

考虑 $L$ 的另一形式有
$$
L=\sum_{e\in E(G)} L_e=\sum_{e\in E(G)} w_e b_e{b_e}^\intercal=BWB^\intercal
$$
因此还可以写成
$$
L\phi=BWB^\intercal \phi=BWI=b
$$
这也是很直观的，对边上的电流分布做一次图上的按邻居求和，就能得到一个节点上的全局电流分布 $b$。

## 电路方程的解

定理：

若 $L\phi=b$ 有解当且仅当 $b\perp \bold1$

"$\Rightarrow$"

注意到 $L$ 实对称，取一组由 $\bold1$ 扩充而来的正交基 $\Set{v_i}$，则 $\phi=a_1\bold1 + \sum_{i=2}^n a_i v_i$

此时 $L\phi=L\left(a_1\bold1+\sum_{i=2}^n a_iv_i\right)=\sum_{i=2}^n a_i\lambda_i v_i$，根据正交基可知 $L\phi\perp b$

直观含义为电阻网络流入的电流要等于流出的电流。

"$\Leftarrow$"

若 $b\perp\bold1$，那么 $b=\sum_{i=2}^n b_iv_i$

此时取 $\phi=\sum_{i=2}^n \frac{b_i}{\lambda_i}v_i$ 即为一个解。

直观含义为对于一组外部电流的电势解，可以任意整体平移得到同方程的其余解（因为电流只和电势差有关）。在固定某个点电势为 $0$ 的前提下，就能得到唯一解。



上面关于 "$\Leftarrow$" 方向的证明用到了一个构造，实际上可以写成
$$
\phi^*=L^\dagger b
$$
其中
$$
\begin{aligned}
L^\dagger&=\sum_{i=2}^n {\lambda_i}^{-1}v_i{v_i}^\intercal
\\
b&=\sum_{i=2}^n {\lambda_i} v_i
\end{aligned}
$$
这意味着，当 $b$ 是一个合法的电流（满足 $b\perp \bold1$）时，$L$ 存在伪逆。并且 $L\phi=b$ 的解集为 $\Set{L^\dagger b + k\bold1\mid k\in \mathbb R}$

## 电势能和等效电阻

同样只考虑单位电阻。

考虑令 $b$ 流入单位电流，电路网络为单位电阻，那么整个电路的等效电阻就是 $s,t$ 间的电势差，即
$$
R_{\text{eff} }=\phi_s-\phi_t=b^\intercal\phi=b^\intercal L^\dagger b
$$
对于电势能同样可以通过等效电阻来算。注意到通的是单位电流，并且电阻为 $R_{\text{eff} }$，因此电势能就是 $R_{\text{eff} }$。

另一种对每条边单独推导的方法如下：
$$
E=\sum_{e\in E(G)} E_e=\sum_{(x,y)\in E(G)} {\left({\phi_x-\phi_y}\right)}^2
$$
回忆关于 $L$ 的二次型，有
$$
E=\phi^\intercal L\phi=R_{\text{eff} }
$$
并且有结论：对与任意的 $s,t$ 流，其电势能不会比 $R_{\text{eff} }$ 更小。即这样的电势分布会最小化单位流的能量损耗，非常神奇的物理意义。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%957-%E7%94%B5%E9%98%BB%E7%BD%91%E7%BB%9C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/14/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%956-FFT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%956-FFT/" class="post-title-link" itemprop="url">计算方法6 FFT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-14 14:49:00" itemprop="dateCreated datePublished" datetime="2022-06-14T14:49:00+08:00">2022-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 12:11:19" itemprop="dateModified" datetime="2022-06-19T12:11:19+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          据助教说不考这么麻烦的计算，我就摸了

          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%956-FFT/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/09/%E5%8D%9A%E5%BC%88%E8%AE%BA2-%E9%9B%B6%E5%92%8C%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/09/%E5%8D%9A%E5%BC%88%E8%AE%BA2-%E9%9B%B6%E5%92%8C%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">博弈论2 零和游戏</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-09 20:34:00" itemprop="dateCreated datePublished" datetime="2022-06-09T20:34:00+08:00">2022-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          # Zero Sum Games

即原本讨论的收益矩阵有两个，分别对应于玩家1和玩家2。零和游戏保证了 $A+B=O$，这说明只需要一个唯一的矩阵即可建模游戏收益，通常规定为玩家1的收益

考虑一个混合策略outcome $(p,q)$，对于玩家1而言收益就是 $p^\intercal Aq$，玩家2就是 $-p^\intercal Aq$。对于纯策略只需要让概率分布坍缩为一个点就行了。



# Min-Max

以下只讨论玩家1，玩家2是类似的。

对于任意的玩家2的混合策略 $q$，玩家1必然会选择使得 $p^\intercal Aq$ 最大化的 $p$，即 $p=\text{argmax } p^\intercal Aq$

而对于任意玩家1的混合策略 $p$，玩家2必然会选择使得 $p^\intercal Aq$ 最小化的 $q$，这说明 $p=\text{argmax}_p\min_qp^\intercal Aq$



## 定理1

$$
\min_q \max_p U(p,q)\geq \max_p \min_q U(p,q)
$$

证明比较玄妙，就是一堆绕来绕去的min-max

首先对于 $U(p,q)$ 将其视为关于 $q$ 的函数，那么有函数在任意点处的函数值不小于其最小值
$$
U(p,q)\ge \min_q U(p,q)
$$
此时将 $U(p,q)$ 和 $\min_q U(p,q)$ 视为 $p$ 的函数，那么两侧加上关于 $p$ 的最大值仍然成立
$$
\max_p U(p,q)\geq \max_p \min_q U(p,q)
$$
此时RHS是一个数，LHS是一个关于 $q$ 的函数，这说明函数的最小值至少为RHS，即
$$
\min_q \max_p U(p,q)\geq \max_p \min_q U(p,q)
$$

## 定理2

若 $p^*,q^*$ 分别是min-max和max-min时，有如下定理：

$(p^*,q^*)$ 是MNE当且仅当它们得到的收益相等。



证明是某次作业



## 定理3

有限策略游戏的混合策略纳什均衡必然存在。

这说明必然存在 $(p^*,q^*)$ 这样的均衡局面，且这样的局面分别是min-max和max-min



## 定理4

在对称零和游戏中，均衡点必然收益为 $0$。

这是显然的，对称零和说明 $A^\intercal=B=-A$，即对角线上收益为 $0$。对于正收益的局面，玩家2总能移动到对角线上获得一个更高的收益；负收益局面玩家1同理。



## 求解

对于玩家1而言即为求解 $\max_p \min_q p^\intercal Aq$，可以等价地转化为如下线性规划：
$$
\text{maximize }v
\\
\text{s.t.}
\\
p^\intercal A\geq v\bold1
\\
\text{where $p$ is a distribution over all strategies}
$$

          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/09/%E5%8D%9A%E5%BC%88%E8%AE%BA2-%E9%9B%B6%E5%92%8C%E6%B8%B8%E6%88%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Lab2-kmt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Lab2-kmt/" class="post-title-link" itemprop="url">操作系统 Lab2 kmt</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-28 16:06:00" itemprop="dateCreated datePublished" datetime="2022-05-28T16:06:00+08:00">2022-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          # Lab2-kmt

花了整个五一三天假期，最后是听了答疑才知道怎么解决栈的数据竞争的....

痛苦的部分主要是多核 logging 和怎么用 qemu debug 的问题。搞定了这些技术上的难题，剩下就是老老实实写代码了。

## 设计

### spinlock

去观摩了 xv6 的代码，发现不仅要自旋，还得关中断。并且关中断这事还得是嵌套的。

### semaphore

每个信号量有一个等待队列 `wait_tid`，一个 `value`，还有一个 `wakeup` 表示需要唤醒多少个睡眠中的进程。

我的实现需要在 `sem_signal` 和 `sem_wait` 中修改全局的任务链表。由于 `os_trap()` 中途也可以 `sem_signal`，所以需要保证对链表读写的互斥。同时由于 `os_trap()` 的第一个操作必须是保存上下文、最后必须是切换，因此需要保证这两个操作对进程状态的修改是符合 `save_context` 后和 `switch_task` 前的语义的。

在调试过程中遇到过一个印象深刻的Bug

一开始我认为只能调度 `RUNNABLE` 的任务，但实际上可以调度所有非 `RUNNING` 的任务。注意到等待信号量进入睡眠后需要一次切换让出 CPU，这就是一种从 `SLEEP` 调度的情况。



##   栈的数据竞争

一开始的上下文切换是通过记录栈上的指针完成的，即每个任务记录一个上下文指针，指向栈上由 AM 的 cte 保存的上下文。

于是就可以观察到，某些时候 `os_trap()` 会返回到空的 `%rip`。

后面每个任务的结构体里都单独拷贝一份上下文，这样就会在多核时出现经典的 triple fault。然后STFW发现可以用 `-d exec` 来打印 trace，用 `-d cpu-reset` 来打印寄存器的值。然后就可以发现每次都是一个线程的 `%rip` 跑飞了，triple fault 就恰好是三次越界指令访问。并且可以发现每次都是在 `cpu_current()` 调用后返回到了错误地址，意味着栈被改写了。

然后我去翻了聊天记录，发现有同学问了一样的问题，但是没有看懂他的解决方案。于是中午去听了答疑，知道了怎么延迟任务T的调度来确保T的栈不会被两个 CPU 同时操作。感觉这个想法还是很厉害的。

但是这样做会出现新的问题：如果用smp=2跑3个任务，那么就会出现问题。CPU[0]从 idle[0]->print，而 CPU[1] 此时无法从 idle[1] 跳到任何任务（一个正在运行，另一个由于栈切换必须等到 CPU[0] 下一次 `os_trap()` 才能调度，但是 `yield()` 的语义是让出 CPU[1]，因此会被我的 `assert` 抓到）

解决方案也很简单。我开了2倍smp的 idle 任务，用于保证每个 CPU 至少可以切换到另一个 idle 上。这样虽然不太优雅，但也还能跑起来。



## tty的神秘Bug

一开始我开了 128 个 `task_struct`，然后在跑 `dev` 的时候滚键盘就会出现某个任务的结构体被修改了的情况。通过 `assert` 和断点找到了是 `tty_render` 会 `memset` 一段内存，然后这段内存恰好处在某两个结构体中间，结果就是改写了我的结构体信息。

这个 Bug 比较难抓到，每7、8次才能复现一次，并且每次导致出错的 `memset` 地址都是一样的（非常整齐，恰好是页面的整数倍）。一开始我以为是 `pmm.c` 的问题，分配的内存和设备地址重叠了。但我打印之后发现并不是这样。而且更神奇的是，我把 `task_struct` 的数量减少到 64 之后，这个 Bug 就再也没法触发了。。。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Lab2-kmt/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Lab1-pmm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Lab1-pmm/" class="post-title-link" itemprop="url">操作系统 Lab1 pmm</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-28 16:03:00" itemprop="dateCreated datePublished" datetime="2022-05-28T16:03:00+08:00">2022-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          # Lab1-pmm

这里不是实验报告，可以随便吐槽和说很多废话吧（大概）
也没有泄漏啥代码，纯纯的唠嗑，应该不违反学术诚信。

感觉这次实验被我做难了....事实上只需要链表就可以实现所有的操作，buddy system 纯纯的没必要，写出来也不容易 debug （也许熟练工可以做到一次对，但是这有啥用呢）

途中卡 smp=8 的时候尝试过 bitmap 和 slab。 bitmap 就是把一个大页分配成64份，用一个 `uint64_t` 状压使用情况，每次直接 `lowbit(bitmap)` 的得到未使用的小块。然后只需要维护两个链表：全满 和 存在空闲。那么一次 fast path 只需要 bit flip 就行了，但事实上过不了。

slab 直接看下面的


## 设计

我区分 thread_list 和 local_list 的设计参考了微软 mimalloc 的实现

### 分配

将 512MiB 的堆区大致分成 8 份，每份用一棵线段树维护以 4KiB 为最小单位的大块内存区间，这样每个 CPU 都有恰好一棵树。因为大块内存的分配需要对齐，且最大分配 8MiB 的内存，因此线段树的端点需要同时 8MiB 对齐和 4KiB 对齐。

对于大小超过 4KiB 的内存分配直接从该CPU的线段树上分配。注意到可能出现该 CPU 分配、其它 CPU 释放的情况，因此每个 CPU 的树在访问时都需要上锁，并且释放时需要释放到分配地。



对于大小不超过 4KiB 的内存分配，先按照 2^k 向上对齐。这里每个 CPU 都有 8 条链表，每个链表专门用于分配固定大小的内存块（例如 16KiB 32KiB 64KiB 128KiB...），这样不同大小的内存分配可以并行（好像没什么卵用，因为每个 CPU 目前都是单线程的）

根据对齐后的大小进入该 CPU 对应大小的链表中，此时每个链表下又分出两个子链表 local 和 thread

1. local 表示本 CPU 分配且本 CPU 释放的内存块
2. thread 表示本 CPU 分配，但是由其它 CPU 释放的内存块

这样做的好处是 local 子链表不需要上锁，因为每个 CPU 都可以看作是单线程的，不存在数据竞争。对于跨 CPU 释放的情形，最坏情况是剩余 n-1 个 CPU 争抢 thread 链表的一把锁。

每次分配小内存，按照如下顺序分配：

1. 查询local链表，有即分配，这是无锁的，且只涉及一个指针的读写操作。
2. 查询thread链表，上锁，移动空余块到local链表，解锁。这部分只涉及到几个指针的读写操作，因此很快。
3. 所属线段树上锁，申请大块空间（16KiB），等分成固定大小，插入到local链表中，解锁。这是 slow-path。

从上到下分别是 快 -> 慢 的顺序



### 释放

对于大小超过 4KiB 的内存块将直接找到所在区间对应的线段树，上锁，释放，解锁。



对于大小不超过 4KiB 的小块内存释放，直接找到其分配时所属的 CPU、分配大小，然后分两类情况

1. 本地分配本地释放，插入到 local 链表中
2. 本地分配外地释放，上锁，插入到 thread 链表中，解锁

注意到要做到上述事情需要记录一些元信息。起初我是通过粗暴地翻倍分配空间、把 header 存在相邻的块中。这样如果每次都分配 129 KiB 的空间，那么就会产生 75% 的浪费。后面想到每个小块内存都是从一个特定大块中划分出来的，且线段树保证了大块内存是按块对齐的。因此直接将给定的地址低位清零找到对应大块的起始位置，在这里留出一个小块记录元信息即可。但是实现完这个之后oj就重测了，也不知道这样子做能不能过掉最后一个 low usage。



还有一个问题是如何区分大块释放（访问线段树）和小块释放（直接修改链表）。一个办法是在元信息中加入MAGIC NUMBER，这样就可以以很小的出错概率区分二者了。



## 印象深刻的Bug

最初的oj有smp=8的狂野case，卡了整整一周都卡不过去，写了8棵线段树都卡不过去，最后的解决方案是干掉case，这样大家就都可以过了，皆大欢喜（摔键盘）
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Lab1-pmm/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/10/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%955-%E5%9B%BE%E7%9A%84%E4%BB%A3%E6%95%B0%E6%80%A7%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/10/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%955-%E5%9B%BE%E7%9A%84%E4%BB%A3%E6%95%B0%E6%80%A7%E8%B4%A8/" class="post-title-link" itemprop="url">计算方法5 图的代数性质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-10 20:48:00" itemprop="dateCreated datePublished" datetime="2022-05-10T20:48:00+08:00">2022-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:47:11" itemprop="dateModified" datetime="2022-06-19T09:47:11+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          感觉这部分穿插的有些怪

upd：最后两节课突然就悟了，因为tcs组主要是做这个的...看了看感觉就是硬广，那就学着吧。

# Courant-Fischer

对于实对称矩阵 $A$，其最大特征值 $\lambda_\max(A)\geq \frac{x^\intercal Ax}{x^\intercal x}$，其中 $x^\intercal x\neq \bold 0$

# 图的代数性质

即对于给定的图 $G$，通过观察 $G$ 的邻接矩阵/拉普拉斯矩阵的性质来获得某些 $G$ 的性质。

## 邻接矩阵

记为 $A$，规定 $A_{x,y}=[xy\in E(G)]$，其中 $[\cdot]$ 为指示函数。

$A$ 还可以写成如下形式
$$
A=\sum_{xy\in E(G)} A^{(xy)}
$$
其中 ${A^{(xy)} }_{x,y}=1$ 其余位置皆为 $0$。即一张图的邻接矩阵可以由所有的边的邻接矩阵拼起来。

显然，对于无向图而言，$A^\intercal=A$

### 特征值

$\lambda_\max(A_G)\leq d_\max(G)$

不妨设最大特征值为 $\lambda$，属于 $\lambda$ 的特征向量 $x$ 的绝对值最大的分量为 $x_i$（不妨设 $x_i>0$），那么有
$$
\lambda x_i=(\lambda x)_i=(Ax)_i=\sum_{j=1}^n A_{i,j}x_j\leq x_i\sum_{j=1}^n A_{i,j}=d(i)x_i \leq d_\max(G) x_i
$$
$\lambda_\max(A_G)\geq d_{\text{avg} }(G)$

只需要用到前置中的定理，令 $x=(\frac{1}{\sqrt{n} },\frac{1}{\sqrt{n} }\ldots \frac{1}{\sqrt{n} })^\intercal$ 即可。

### 二分图

若 $G$ 为二分图，则其邻接矩阵 $A$ 为

1. 对称阵，$A^\intercal =A$。
2. 分块矩阵，有 $\begin{bmatrix}0 & B \\ B^\intercal & 0\end{bmatrix}=A$。这是因为存在点集 $V(G)$ 的划分 $\set{U,V}$ 使得 $V,U$ 的内部没有边，即邻接矩阵存在子矩阵为全 $0$ 矩阵。



对于二分图，若 $\lambda$ 为邻接矩阵 $A$ 的 $k$ 重特征值，那么 $-\lambda$ 必然也为 $A$ 的 $k$ 重特征值。

证明：

不妨设属于 $\lambda$ 的特征向量为 $v=\begin{bmatrix}{x}\\{y}\end{bmatrix}$，那么有 $Av=\lambda v$，即 $\left\{\begin{aligned}By&=\lambda x\\B^\intercal x&=\lambda y\end{aligned}\right.$

此时构造 $v'=\begin{bmatrix}x\\-y\end{bmatrix}$，那么有 $Av'=\begin{bmatrix}-By\\B^\intercal x\end{bmatrix}=-\lambda\begin{bmatrix}x\\-y\end{bmatrix}$，这说明 $v'$ 是属于特征值 $-\lambda$ 的特征向量。

当 $\lambda$ 重数为 $k$ 时，有 $k$ 个属于 $\lambda$ 的线性无关的特征向量，这 $k$ 个分别取反就得到了 $k$ 个属于 $-\lambda$ 的特征向量。



反之，若按顺序排布特征值 $\lambda_1,\lambda_2\ldots \lambda_n$，有 $\forall i, \lambda_i=-\lambda_{n-i+1}$ 成立，那么 $G$ 是二分图。

证明：

对于任意的奇数 $k$，有
$$
tr(A^k)=\sum_{i=1}^n {\lambda_i}^k=\frac12\sum_{i=1}^n \left({\lambda_i}^k + {\lambda_{n-i+1} }^k\right)=0
$$
考虑 $(A^k)_{i,j}$，其组合含义为 $i,j$ 点对之间长度恰为奇数 $k$ 的路径数量。根据矩阵迹的定义又有：
$$
tr(A^k)=\sum_{i=1}^n (A^k)_{i,i}=0
$$
由于 $A$ 所有元素非负，因此 $\forall i, (A^k)_{i,i}=0$，这说明对于任意奇数长度的圈，图 $G$ 中都不存在。这恰好是二分图的充要条件。

## 拉普拉斯矩阵

也叫调和矩阵，在矩阵树定理里面叫做基尔霍夫矩阵。

规定 $L=D-A$，其中 $D=\text{diag}\{d_1,d_2\ldots d_n\}$ 是度数对角阵。



对于边 $e=(x,y)$ 定义 $L_{e}$ 是 $L_e[x,y]=L_e[y,x]=1$，$L_e[x,x]=L_e[y,y]=-1$，其余为 $0$ 的矩阵。那么有
$$
L=\sum_{e\in E(G)} L_e
$$
类似 $A$，可以将 $L$ 视为所有边相加得到的图。这个形式对于 $L$ 的二次型非常有用，有如下形式：
$$
x^\intercal Lx=\sum_{e\in E(G)} x^\intercal L_e x=\sum_{e=(i,j)\in E(G)} (x_i-x_j)^2
$$
由上式立刻得到 $L\succeq 0$ 为半正定矩阵，列举特征值将有 $0= \lambda_1\le \lambda_2\cdots \lambda_n$。

### 特征值

$\bold 1$ 是 $L$ 的一个特征向量，对应特征值为 $0$。即 $L\bold 1=\bold 0$

证明：拆开即得。



$G$ 连通，当且仅当 $L$ 的特征值 $0$ 重数为 $1$。

"$\Leftarrow$"：

假设 $G$ 不连通，则 $L$ 可以写成 $\begin{bmatrix}B & 0 \\ 0 & C\end{bmatrix}$。注意到至少存在两个属于特征值 $0$ 的特征向量$\begin{bmatrix}\bold 1\\ \bold0\end{bmatrix}$ 和$\begin{bmatrix}\bold 0\\ \bold1\end{bmatrix}$

"$\Rightarrow$"：

已知 $G$ 连通，那么取属于 $0$ 的特征值 $x$，有 $x^\intercal Lx=\sum_{(i,j)\in E(G)} (x_i-x_j)^2=0$。这说明 $\forall (i,j)\in E(G)$ 都有 $x_i=x_j$，由连通性立即得到 $x=k\bold1$，即重数为 $1$。

结合半正定性立即有 $0=\lambda_1< \lambda_2\le \cdots \lambda_n$，也就是 $G$ 连通当且仅当 $\lambda_2>0$





剩下的咕咕咕
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/10/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%955-%E5%9B%BE%E7%9A%84%E4%BB%A3%E6%95%B0%E6%80%A7%E8%B4%A8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/10/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%954-%E5%9B%BE%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/10/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%954-%E5%9B%BE%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/" class="post-title-link" itemprop="url">计算方法4 图的随机游走</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-10 19:58:00" itemprop="dateCreated datePublished" datetime="2022-05-10T19:58:00+08:00">2022-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Markov Chain 的本质是概率状态机，这么想就很简单了

为了偷懒只讨论有限的情形

# 前置

离散概率分布可以表示为 $\R^n$ 上的向量 $x$，满足 $\sum_{i=1}^n x_i=1$ 且 $\forall i,x_i\in[0,1]$

对于用向量表示的概率分布，可以定义两个分布的“距离”：
$$
d_{TV}(p,q)=\frac{1}{2}\norm{p-q}_1=\frac{1}{2}\sum_{i=1}^n\abs{p_i-q_i}
$$
这里 $d_{TV}(,)$ 表示 total variation distance。这样就可以定义一列分布的收敛性和极限了。

# Markov Chain

对于一系列数量有限的状态，给出每个状态转移到下一个状态的概率 $Pr[s_i=y\mid s_{i-1}=x]$，这就构成了一个状态机。把状态看成点，转移概率看成边权，就得到了一个有向带权图，并且这个图满足一些特殊的性质。

考虑怎么算出现在状态 $i$ 的概率，这本质上是一个一阶递推，写出来就是
$$
p_{k+1}=Tp_k
$$
这里 $p_k$ 表示走了恰好 $k$ 步后，处在每个状态上的概率分布

## 定义

### 周期

对于状态 $i$，其周期定义为 $gcd\{t\mid {P^t}_{i,i}>0\}$，记为 $period(i)$。称 Markov Chain 非周期当且仅当所有状态的周期都是 $1$

直观理解：从 $i$ 出发后走恰好 $t$ 步回到 $i$，所有这样的圈的长度的 gcd 即为周期。

这么定义的用处可以在后面看到。

### 不可约

有限图不可约当且仅当其为强连通图。此处强连通的定义为：任取 $x,y\in V(G)$，存在两条有向路径 $P_1,P_2$ 使得 $P_1=x\rightsquigarrow y,P_2=y\rightsquigarrow x$。**不要求 $P_1,P_2$ 点不相交**

## 性质

若 Markov Chain 不可约、非周期，则存在常数 $T$ 使得当 $t>T$ 时，${P^t}_{i,j}>0$ 对任意 $i,j$ 成立

直观理解：走了足够多步后不存在走不到的状态。

只需要证明存在常数 $L$，使得任意长度至少为 $U$ 的路径，都能在任意两点间找到。

1. 不可约，则 $i,j$ 存在有向路径 $i\rightsquigarrow j$。
2. 非周期，则存在最大的无法由两个圈线性组合出的正整数 $a\times b-a-b$ （NOIP2017，哈哈），记为 $mn(i)$，则此后的任意长度都可以由两个互质的圈线性组合出来。
3. 只需要取 $T=n+\max\{mn(i)\}$，则此后可以在任意节点对之间游走。

## 稳态分布

考虑给定初始分布 $p_0$，则极限 $\lim\limits_{k\to\infty} P^k p_0$ 称为 Markov Chain 的极限分布。

若分布 $\pi$ 满足 $P\pi=\pi$，则称 $\pi$ 为平衡分布。可以证明极限分布若存在则必然为平衡分布。

设极限分布存在 $\lim\limits_{k\to\infty}P^k\pi_0=\pi'$，那么有
$$
P\pi'=P\lim\limits_{k\to\infty} P^k\pi_0=\lim\limits_{k\to\infty} P^{k+1}\pi_0=\pi'
$$
这说明 $P\pi'=\pi'$ 是一个平衡分布。

## Markov Chain 基本定理

若 Markov Chain 不可约、非周期，那么

1. 存在稳态分布 $\pi$
2. 对于任意的 $p_0$ 都有 $\lim\limits_{k\to\infty} P^k p_0=\pi$
3. $\pi$ 是唯一的
4. $\pi_i=\dfrac{1}{E[H_i]}$，其中 $H_i$ 为随机变量，表示从 $i$ 出发后第一次回到 $i$ 的行走步数。$E[H_i]$ 称为期望回归时间。

出现这个结论的原因在于，足够久之后任意点出发都将能走到任何点，因此两个不同的出发状态在足够久之后将“无法区分”

具体的证明看不懂，咕咕咕



# Page Rank

Google 提出的给网页打分的算法。它假设

1. 每个用户在页面 $x$ 浏览完后，将等概率点击一个 $x$ 中的超链接（即等概率走向一个邻居）
2. 每个用户在页面 $x$ 浏览完后，有一定概率直接跳转到任意一个页面 $y$

可以发现 2 本质上就是新建超级点 $S$，然后每个点连向 $S$，再从 $S$ 连回所有点。

注意到 1 实际上就是在有向图上随机游走，转移矩阵恰好为度数导出的一个概率矩阵。2 保证了即使原图不是非周期、强连通时，用户这样的操作仍然可以使得随机游走存在一个稳态分布/极限分布（新图是强连通/非周期的，why？）。直觉也是符合的，每个人可能会突然停止浏览，然后从另一个完全不相关的页面重新开始冲浪。

并且这样的分数（概率分布）只与图的结构有关，与初始迭代向量没有关系。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/10/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%954-%E5%9B%BE%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%953-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/08/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%953-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/" class="post-title-link" itemprop="url">计算方法3 线性方程组求解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-08 14:33:00" itemprop="dateCreated datePublished" datetime="2022-05-08T14:33:00+08:00">2022-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:47:11" itemprop="dateModified" datetime="2022-06-19T09:47:11+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          # 前置

这一节主要是玩矩阵，为了偷懒只讨论实线性空间

# 前置

这一节主要是玩矩阵，为了偷懒只讨论实线性空间

## 内积

二元函数 $\left<,\right>$ 被称为内积，则其满足：

1. $\left<x,y\right>=\left<y,x\right>$
2. $\left<ax+by,z\right>=a\left<x,z\right>+b\left<y,z\right>$
3. $\left<x,x\right>\geq 0$，等号仅在 $x=\bold{0}$ 时取到

## 向量范数

一元函数 $\norm{\cdot}$ 被称为范数，则其满足：

1. $\norm{x}\geq 0$，等号仅在 $x=\bold0$ 时取到
2. $\norm{kx}=\abs{k}\norm{x}$
3. $\norm{x+y}\leq \norm{x}+\norm{y}$

在内积空间上有一个天然的范数 $\norm{x}=\sqrt{\left<x,x\right>}$，容易验证满足上述三条要求。

## 矩阵范数

### 算子范数

矩阵可以看成线性变换，因此可以由向量范数来衡量矩阵作为线性变换（算子）的“长度”。定义为
$$
\norm{A}=\max_{\norm{x}=1} \norm{Ax}
$$
注意这里的 $Ax,x$ 都是向量，因此 RHS 出现的全都是向量范数，LHS 则是定义出来的算子范数。

有了这个定义，我们就可以写出这样的不等式
$$
\norm{Ax}\leq \norm{A}\norm{x}
$$
同时会引入新的定义，称满足下述要求的算子范数具有**相容性**：
$$
\norm{AB}\le \norm{A}\norm{B}
$$
有了相容性同样可以做一些界的估计

### 矩阵范数

矩阵同样也可以看成线性空间中的元素，因此可以单独赋予范数的定义，当然这就和向量范数没什么关系了。

一个例子是这样的，容易验证其满足三条要求
$$
\norm{A}=\sum_{i,j}\abs{A_{i,j} }
$$


# 高斯消元

对于给定的线性方程组 $Ax=b$，可以用简单 $O(n^3)$ 的高斯消元法来求解。并且这样可以很容易地求出解空间的一组基，进而得到所有解。

## 解的稳定性

不妨假设 $A=xb$ 中 $\abs{A}\neq0$，则有 $x=A^{-1}b$

通常 $A$ 是给定的，而 $b$ 是若干计算和观察的结果，因此解的误差主要来源于 $b$ 引入的误差，可以写成
$$
\hat x=A^{-1}\hat b
$$
考虑相对误差的计算，即为
$$
\max_{\hat b,b\neq0} {\frac{\norm{A^{-1}\hat b} }{\norm{A^{-1}b} } }/{\frac{\norm{\hat b} }{\norm{b} } }
$$
即后向相对误差与前向相对误差的比值，称这个值为方程组 $A$（矩阵 $A$）的条件数 $\text{cond}(A)$
$$
\begin{aligned}
\text{cond}(A)&=\max_{\hat b,b\neq 0}  {\frac{\norm{A^{-1}\hat b} }{\norm{A^{-1}b} } }/{\frac{\norm{\hat b} }{\norm{b} } }
\\
&=\max_{\hat b\neq 0} \frac{\norm{A^{-1}\hat b} }{\norm{\hat b} }\max_{b\neq 0}\frac{\norm{b} }{\norm{A^{-1}b} }
\end{aligned}
$$
注意到 $A^{-1}b=x$，且 $b=Ax$，带入即得
$$
\begin{aligned}
\text{cond}(A)&=\max_{\hat b\neq 0}\frac{\norm{A^{-1}\hat b} }{\norm{\hat b} }\max_{x\neq 0} \frac{\norm{Ax} }{\norm{x} }
\\
&=\norm{A^{-1} }\norm{A}
\end{aligned}
$$
矩阵的条件数反映了矩阵所对应线性方程组的不稳定程度。条件数越大则不稳定程度越大，误差的传递放大也就越严重。

# 迭代算法

$O(n^3)$ 太昂贵，考虑迭代算法。一般而言迭代的次数是人为规定的，不少算法能够保证在 $\Omega(n)$ 次迭代之后必然得到精确解。

## Jacobi 迭代

对于矩阵 $A$，将其分解为 $A=L+D+U$，其中 $L,U$ 分别为上三角矩阵和下三角矩阵，$D$ 为对角阵。

那么有
$$
Ax=(L+U+D)x=b
\\
x_{k+1}=D^{-1}(b-(L+U)x_k)
$$

### 收敛性

给出一个充分条件：若 $A$ 是主对角线占优矩阵，则迭代必然收敛。

只需联立如下方程
$$
\left\{
\begin{aligned}
x^*&=D^{-1}(b-(L+U)x^*)
\\
x_{k+1}&=D^{-1}(b-(L+U)x_{k})
\end{aligned}
\right.
$$
两式相减即得
$$
x_{k+1}-x^*=-D^{-1}(L+U)(x_k-x^*)
$$
记 $W=D^{-1}(L+U)$，由对角占优可知 $Wx$ 的每一项绝对值严格小于 $x$，因此迭代收敛。

### 正确性

假设收敛，则有不动点 $x$，简单替换即得不动点 $x$ 是原方程的一个解。

结合收敛性的充分条件即得：若 $A$ 为主对角线占优矩阵，则解唯一（$A$ 可逆），且迭代收敛至唯一解。

看起来还是比较好的。

## Gauss-Seidel 迭代

用到了一个观察，即在计算解向量 $x_{k+1}$ 的第 $r$ 项时，它的前 $r-1$ 项都已经算出来了（废话）

因此可以写成
$$
x_{k+1}=D^{-1}(b-Ux_k-Lx_{k+1})
$$
证明和上面是类似的，结论也是类似的。

写代码可以发现这两个方法没有绝对的好坏之分，迭代速度也没有一般性的结论（至少俺不知道）。



## 谱半径

为了分析一类迭代算法的收敛性，引入谱半径的概念

定义 $A$ 的谱半径为其绝对值最大的特征值 $\abs{\lambda_\max}$，记为 $\rho(A)$



对于这样的迭代算法
$$
x_{k+1}=Ax_k+b
$$
取不动点做差得
$$
x_k-x^*=A^k(x_0-x^*)
$$
如果能说明 $\lim\limits_{k\to\infty} A^k=O$，那么就能说明迭代是收敛的，且收敛到方程组的解。

有定理：$\lim\limits_{k\to\infty}A^k=O$ 当且仅当 $\rho(A)<1$



分析 Jacobi 和 Gauss-Seidel 迭代矩阵的谱半径可以知道，当系数矩阵 $A$ 是严格对角占优时，这两个算法以任意初始向量开始迭代都会收敛。



## 伪逆

对于满秩矩阵 $A$，方程组 $Ax=b$ 的解是显然存在的。但是对于非满秩的矩阵 $B$ 来说就不一定了。在最小二乘法中可以求得一个二范数最小的“逼近”解，实际上是解了一个方程 $A^\intercal Ax=A^\intercal b$，即 $x=(A^\intercal A)^{-1}A^\intercal b$



问题的关键在于 $A^{-1}$ 不一定存在，这使得 $Ax=b$ 不一定存在唯一解。因此引入记号 $A^\dagger=(A^\intercal A)^{-1}A^\intercal$，称为 $A$ 的伪逆（pseudo inverse），那么最小二乘法可以写成 $x=A^\dagger b$，形式与满秩方程组 $x=A^{-1}b$ 是一致的。这样求出的解为最佳平方逼近解。



当 $A$ 的列线性无关时，$A^\intercal A$ 满秩，$A^\dagger=(A^\intercal A)^{-1}A^\intercal$ 存在。此时原方程组 $Ax=b$ 无解（超定方程组）

由反证法假设存在 $x\neq 0$ 使得 $A^\intercal Ax=0$，那么 $(Ax)^\intercal (Ax)=0$，根据内积的正定性可知 $Ax=0$，这说明存在列的线性组合为 $0$，这与列线性无关矛盾；故假设不成立。



类似取 $A^\intercal$ 可知，当 $A$ 的行线性无关时，$A^\intercal$ 列线性无关，$AA^\intercal$ 满秩，$A^\dagger=((A^\intercal)^\dagger)^\intercal=A^\intercal(AA^\intercal)^{-1}$。此时方程组 $Ax=b$ 有多解（欠定方程组），但是我不知道有啥意义，因为 $A^\dagger$ 是个右逆....
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/08/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%953-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%952-%E6%8F%92%E5%80%BC%E4%B8%8E%E5%87%BD%E6%95%B0%E9%80%BC%E8%BF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/08/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%952-%E6%8F%92%E5%80%BC%E4%B8%8E%E5%87%BD%E6%95%B0%E9%80%BC%E8%BF%91/" class="post-title-link" itemprop="url">计算方法2 插值与函数逼近</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-08 11:33:00" itemprop="dateCreated datePublished" datetime="2022-05-08T11:33:00+08:00">2022-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:47:11" itemprop="dateModified" datetime="2022-06-19T09:47:11+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          心态崩了，这个 latex 公式支持也太迷幻了。但是不太想管，等啥时候有空整个自己的吧(flag++)

# 函数逼近

考虑的是对于给定函数 $f$ 和度量 $\norm{\cdot}$，求一个多项式函数 $p$ 使得 $\norm{f-p}$ 尽可能小。这里不关注特定点上的值，而更在意两个函数总体的距离。

## Weierstrass 逼近定理

若 $f\in C[a,b]$，那么存在多项式列 $\left\{F_n\right\}$，使得 $\norm{\lim\limits_{n\rightarrow\infty} F_n -f}_{\infty}=0$

$\norm{f}_{\infty}$ 的含义是 $\sup R(f)$，即值域的上确界。

注意到 $[a,b]$ 是任意的。为了便于讨论，一般通过伸缩平移到 $[-1,1]$ 上考虑。



Bernstein（又是他）给了一个构造性的证明，他构造出的多项式即为大名鼎鼎的Bernstein多项式。证明的技巧比较强，这里就不放了，感觉再抄一遍也没啥用....

## Chebyshev 多项式

特殊的多项式族，规定了 $n$ 次多项式一致逼近的误差下界。

### 定义

是一组多项式列 $\left\{T_n\right\}$，其中 $T_n$ 是次数为 $n$ 的多项式
$$
T_n(x)=\cos(n\arccos x)
$$
令 $\arccos x=\theta$ 注意到
$$
T_{n+1}(x)=\cos((n+1)\theta)=\cos n\theta\cos\theta-\sin n\theta\sin\theta
\\
T_{n-1}(x)=\cos((n-1)\theta)=\cos n\theta\cos\theta+\sin n\theta\sin\theta
$$
可得等价的递推式如下
$$
\begin{aligned}
T_0(x)&=1
\\
T_1(x)&=x
\\
\cdots
\\
T_{n+1}(x)&=2xT_n(x)-T_{n-1}(x)
\end{aligned}
$$

### 性质

1. $T_n(x)$ 是 $n$ 次多项式，首项系数为 $2^{n-1}$。归纳可得。
2. $T_n(x)$ 的值域为 $[-1,1]$。这是个 $\cos$ 函数。
3. $T_n(x)$ 的零点恰好为 $n\arccos x=\dfrac{\pi}{2}+k\pi$ 的解，解恰有 $n$ 个。
4. $T_n(x)$ 在 $[-1,1]$ 之间震荡，并恰好变号 $n+1$ 次。
5. $T_n(x)=\prod_{i=1}^n (x-x_i)$，其中 $x_i$ 是性质 3 中的第 $i$ 个解。



并且有：任给 $n$ 次首一多项式 $P_n(x)$，都有 $\norm{\frac{1}{2^{n-1} }T_n(x)}_\infty\leq \norm{P_n(x)}_\infty$，且 $\norm{\frac{1}{2^{n-1} }T_n(x)}_\infty=\frac{1}{2^{n-1} }$

由反证法，假设存在更小的 $P'_n(x)$，则 $\Delta(x)=\frac{1}{2^{n-1} }T_n(x)-P'_n(x)$ 将会存在至少 $n$ 个零点。而 $\Delta(x)$ 至多是 $n-1$ 次多项式，这说明 $\Delta(x)\equiv 0$



Chebyshev 多项式给了我们一个最小化形如 $\prod (x-x_i)$ 这样多项式的办法：设定 $x_i$ 的值为 Chebyshev 多项式的零点，这样本身就得到了一个 Chebyshev 多项式。由其性质即得多项式的最值是同次首一多项式中最小的。



# 函数插值

## Lagrange Interpolation

假设给了 $n$ 个二维平面上的点对 $\left\{(x_i,y_i)\right\}$，如何求出一个函数恰好经过这 $n$ 个点？



考虑这么一个函数 $L_i^*(x)=\prod_{j\neq i}(x-x_j)= (x-x_1)(x-x_2)\cdots(x-x_{i-1})(x-x_{i+1})\cdots(x-x_n)$，它有如下性质：

1. $\deg L_i^*(x)\leqslant n-1$
2. $L_i^*(x_j)=0,i\neq j$
3. $L_i^*(x_i)=(x_i-x_1)(x_i-x_2)\cdots(x_i-x_{i-1})(x_i-x_{i+1})\cdots(x_i-x_n)$

为了方便我们可以配上一个系数，那么就得到 $L_i(x)=\dfrac{L_i^*(x)}{L_i^*(x_i)}$

于是就有 $L_i(x_j)=\delta_{i,j}$，其中 $\delta_{i,j}$ 为kronecker记号。

再继续构造 $F(x)=\sum\limits_{i=1}^n y_iL_i(x)$，根据上面的性质可知 $\forall i\in[n],F(x_i)=y_i$

这样拉格朗日就得到了这么一个经过 $n$ 个点的多项式，且 $F(x)$ 是多项式，有 $\deg F(x)\leqslant n-1$



## 唯一性

假设存在多项式 $G$ 使得 $F(x)\neq G(x)$ 且 $\deg G(x)\leqslant n-1$，但 $\forall i\in [n], G(x_i)=F(x_i)=y_i$

此时构造 $H(x)=F(x)-G(x)$，则 $H(x)$ 至多 $n-1$ 次且有至少 $n$ 个零点，由代数基本定理可知 $H(x)\equiv 0$，这与 $G\neq F$ 矛盾。



## 误差分析

不妨假设 $x_0\le x_1\le\cdots \le x_n$
$$
R_n(x)=f(x)-P_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!} {\prod_{i=0}^{n} (x-x_i)}
$$
其中 $\xi\in(x_0,x_n)$，$f\in C^{n+1}[x_0,x_n]$



固定一个 $x$，构造关于变元 $t$ 的函数
$$
\varphi(t)=f(t)-P_n(t)-R_n(x)
$$
则 $\varphi(t)$ 在 $[x_0,x_n]$ 上有至少 $n+2$ 个零点：

1. $t=x_i$，$\varphi(x_i)=f(x_i)-P_n(x_i)-R_n(x)=0$
2. $t=x$，$\varphi(x)=f(x)-P_n(x)-R_n(x)=0$

因此相邻的两个零点两两用中值定理即得 $\varphi^{(n+1)}(t)$ 在 $[x_0,x_n]$ 上有至少一个零点，展开即为 $R_n(x)$ 的形式。



## 最小化误差

即我们既想插值，又想让插值多项式与目标函数尽量逼近。



回顾插值余项 $R_n(x)$ 的定义，令 $\omega_n(x)=\prod_{i=0}^n (x-x_i)$，最小化 $\omega_n$ 即可最小化 $R_n$，这一点通过选取特殊的插值点来实现。

回想 Chebyshev 多项式的性质，我们只需要选取 $\{x_i\}$ 使得 $n\arccos x_i=\dfrac{\pi}{2}+k\pi$ 即可。这样插值出来的多项式被称为 Chebyshev 插值多项式。

# 最小二乘法

很多时候度量的选取是任意的，例如上面就选择了 $\norm{}_\infty$ 作为函数逼近的度量。在选取 $\norm{}_2$ 作为度量时，则可以使用最小二乘法的办法来找到最佳平方逼近。

我们知道次数至多为 $n$ 的多项式函数构成了 $n+1$ 维线性空间。最小二乘法的本意即为用一个低维的线性空间来最佳地表征高维空间中的向量（或者反过来，求一个高维向量在低维空间中的投影），这样用于求平方逼近就是很自然的想法了。

为了方便坐标表示和运算，通常要求出一组多项式的正交基，然后就可以在坐标下讨论多项式逼近了。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/05/08/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%952-%E6%8F%92%E5%80%BC%E4%B8%8E%E5%87%BD%E6%95%B0%E9%80%BC%E8%BF%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/12/%E5%8D%9A%E5%BC%88%E8%AE%BA1-%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/12/%E5%8D%9A%E5%BC%88%E8%AE%BA1-%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">博弈论1 策略游戏</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-12 22:29:00" itemprop="dateCreated datePublished" datetime="2022-03-12T22:29:00+08:00">2022-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          # Pure Strategy Games

策略博弈说的是有限个玩家，每个玩家都有有限个决策，并且每个玩家的决策必须同时作出（即不能知悉其他人的决策），每个玩家都知道每一种决策组合的结果给每个玩家带来的收益。

形式化地，有

1. $N$ 个玩家构成有限的玩家集
2. 每个玩家 $i$ 都有一个有限的决策集 $A_i$，表示其所有可以选择的决策
3. 一个局面 $a\in A=\prod\limits_{i=1}^N A_i$，包含了场上所有玩家所作出的决策
4. 每个玩家 $i$ 都有一个收益函数 $u_i\colon A\mapsto \mathbb K$，其中 $\mathbb K$ 是一个全序集

之所以定义为全序集是因为并非所有收益都是可以计算出来的数值，但是我们希望任意两个收益是可以比较好坏的



为了简化，规定

1. $a_{i-1}\in A_{-i}=\prod\limits_{i\neq j} A_j$ 表示玩家 $i$ 的所有对手的某种决策局面
2. 由1，某个局面 $a$ 就可以写成是 $(a_i,a_{-i})$，注意到我们并不关心局面的枚举顺序，因此这里实际上是集合而不是笛卡尔积....
3. 记 $B_i(a_{-i})=\underset{a_i}{\arg\max}\; u_i(a_i,a_{-i})$ 为玩家 $i$ 的所有对手选择了 $a_{-i}$ 决策时，所有能最大化玩家 $i$ 的收益的决策集，称为 $i$ 的 Best Response



## Dominant Strategy

对于玩家$i$而言，某些决策严格劣于其余决策，因此是绝对不会选的，可以直接删掉。

上述过程可以持续进行直至不存在被严格支配的决策，这样可以化简求解时的难度



## Nash Equilibrium

若一个局面 $a=(a_i,a_{-i})$ 满足对于一切的玩家 $i$ 都有命题 $\forall c\in A_i$ ，$U_i(a_i,a_{-i})\succeq U_i(c,a_{-i})$ 成立，那么称局面 $a$ 为一个（单一策略的）纳什均衡点

可以这么考虑：在纳什均衡的局面下，每个玩家单方面地作出决策变动都将让ta的收益下降。



一个简单的求解套路是对每个玩家 $i$ 求出 $U_i(\cdot)$，然后求 $\dfrac{\partial}{\partial a_i} U_i(a_i,a_{-i})$ 来得到一个 $a_i^{*}\in B_i(a_{-i})$。显然在均衡点时，每个玩家都要最大化，那么联立求解就得到了一组解 $a^*=(a_i^*,a_{-i}^*)$。



注意这里的纯策略纳什均衡不一定存在，反例非常好找。并且若存在也不一定唯一，例如"剪刀石头布"的博弈模型就有三个均衡点。



## 求解PNE

可以枚举所有的outcome来逐一判断每个人是否都达到了最优，可以看成寻找一个超立方体上的“鞍点”。



# Mixed Strategy Game

纯策略意味着每个人的决策是唯一确定的，这个前提太强。一个放松是给出选择每个决策的概率，即一个 $A_i$ 上的概率分布 $p_i$

记 $\Delta(A_i)$ 为玩家 $i$ 的决策集 $A_i $ 上所有可能的概率分布的集合，那么每个玩家的决策就会是一个决策集上的分布 $p_i\in \Delta(A_i)$

同样记 $p=(p_i,p_{-i})$

给出 $U_i(p)=\sum\limits_{a\in A}Pr[X=a]u_i(X)$，其中 $X\sim p$ 为一个随机变量

注意到每个玩家互不交流，因此它们的决策相互独立，拆开就得到 $U_i(p)=\sum\limits_{a\in A}u_i(a)\prod\limits_{i=1}^N p_j(a_j)$，这其实就是一个收益的期望，随机性来源于 $N$ 个独立分布的叠加。



## 定理1

若 $p=(p_i,p_{-i})$ 是一个纳什均衡，那么所有使得 $p_i(a)>0$ 的决策 $a$ 都将会是局面 $(a,p_{-i})$ 的 Best Response。

意思是对于一个纳什均衡的局面 $p=(p_i,p_{-i})$，在固定了对手的所有决策分布之后，玩家 $i$ 可能选择的单一决策（概率不为 $0$ 的那些决策）的每一个都将是应对 $p_{-i}$ 的最佳选择。



证明只需要反证一下，假设某个 $p_i(a)>0$ 但 $a\not\in B_i(p_{-i})$，那么构造一个新的分布 $p_i'$ 满足 $p_i'(a)=0$ 且其余非零位置都乘上 $\frac1{1-p_i(a)}$，可以证明新的分布下将达到更大的 $U_i(p_i')$，这与 $(p_i,p_{-i})$ 是纳什均衡矛盾；但是反过来不一定成立，例如可以存在多个单独最优解，但是我们不随机，只选择其中一个策略。



这个引理还是比较强的，说明即使引入了随机性，每个玩家的选择仍然是固定的，只不过现在变成了固定的集合。



## Mixed Nash Equilibrium

每个finite strategy game都有至少一个混合策略的纳什均衡，称为Mixed Nash Equilibrium(MNE)

这个定理也是Nash证明的，算是比较漂亮的定理了。



## 求解MNE

### profile enumeration

对于一个非退化的2人游戏，可以 $2^n$ 枚举概率非 $0$ 的决策解一个不等式组。不妨设枚举出的行抽取出的矩阵为 $A$，那么对于玩家1而言必然有 $Aq$ 的每一元素都相等（根据定理1）且严格大于剩余行的期望收益。

### vertex enumeration

可以发现上面等价于给定原收益矩阵 $M$，要求对于玩家1而言满足
$$
\forall \text{distribution } q
\\
Mq\ge v\bold1
\\
\text{maximize } v
$$
这样的解构成了一个闭凸多边形，边界上的解代表某些约束取到了等号。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/12/%E5%8D%9A%E5%BC%88%E8%AE%BA1-%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/Ubuntu%E4%B8%8B%E7%9A%84%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/08/Ubuntu%E4%B8%8B%E7%9A%84%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Ubuntu下的数电实验环境配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-08 13:06:00" itemprop="dateCreated datePublished" datetime="2022-03-08T13:06:00+08:00">2022-03-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          针对南京大学 数字逻辑与计算机组成实验 课程的环境配置，本机是Ubuntu 21.10

# 1

访问 [这个网页](https://www.intel.com/content/www/us/en/software-kit/660904/intel-quartus-prime-lite-edition-design-software-version-20-1-1-for-linux.html?)，选择Individual Files，只需要下载

1. QuartusLiteSetup-20.1.1.720-linux.run (1.9GB)
2. cyclonev-20.1.1.720.qdz (1.3GB)



# 2

进入下载目录，执行以下操作

```bash
chmod +x QuartusLiteSetup-20.1.1.720-linux.run
./QuartusLiteSetup-20.1.1.720-linux.run
```

途中选择带有 Free License 字样的 Modelsim-Questa



# 3

再参照[这个回答](https://stackoverflow.com/questions/31908525/modelsim-altera-error)，命令行执行以下操作

```bash
sudo apt-get install libxft2 libxft2:i386 lib32ncurses6
```

第二个是必须的，这样就解决了 RTL Simulation 时，弹窗报错需要 LD_LICENSE_FILE 环境变量的问题。



# 4

参照[Intel官方文档](https://www.intel.com/content/www/us/en/docs/programmable/683076/current/installing-on-red-hat-enterprise-5-and-6.html)，以su权限修改`/etc/udev/rules.d/51-usbblaster.rules`文件，添加：

```bash
# Blaster I
BUS=="usb", SYSFS{idVendor}=="09fb", SYSFS{idProduct}=="6001", MODE="0666"
BUS=="usb", SYSFS{idVendor}=="09fb", SYSFS{idProduct}=="6002", MODE="0666" 
BUS=="usb", SYSFS{idVendor}=="09fb", SYSFS{idProduct}=="6003", MODE="0666"
# Blaster II
BUS=="usb", SYSFS{idVendor}=="09fb", SYSFS{idProduct}=="6010", MODE="0666"
BUS=="usb", SYSFS{idVendor}=="09fb", SYSFS{idProduct}=="6810", MODE="0666"
```

具体关于udev是干什么的，可以看archwiki



# 5

在`/usr/share/applications/`目录下以su权限新建`quartus.desktop`，输入以下内容

```bash
[Desktop Entry]
Type=Application
Version=0.9.4
Name=Quartus (Quartus Prime 20.1) Lite Edition
Comment=Quartus (Quartus Prime 20.1)
Icon=/home/jjppp/intelFPGA_lite/20.1/quartus/adm/quartusii.png
Exec=/home/jjppp/intelFPGA_lite/20.1/quartus/bin/quartus --64bit
Terminal=false
Path=/home/jjppp/intelFPGA_lite/20.1
```

这样就可以找到quartus作为程序的图标了



# 6

可以安装wine，那么就可以利用System Builder来生成已经分配好引脚的工程文件了。



# 总结

中途遇见了很多奇怪的问题，最奇怪的是LD_LICENSE_FILE的问题，明明是免费版本却出现了需要一个不存在的license.dat文件的情况.....最后是通过"Questa-Modelsim LD_LICENSE_FILE"搜到的解决方案，不然就得去翻log了。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/08/Ubuntu%E4%B8%8B%E7%9A%84%E6%95%B0%E7%94%B5%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%951-%E5%87%BD%E6%95%B0%E6%B1%82%E6%A0%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/07/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%951-%E5%87%BD%E6%95%B0%E6%B1%82%E6%A0%B9/" class="post-title-link" itemprop="url">计算方法1 函数求根</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-07 23:26:00" itemprop="dateCreated datePublished" datetime="2022-03-07T23:26:00+08:00">2022-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:47:11" itemprop="dateModified" datetime="2022-06-19T09:47:11+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          严格写就太累了，这个就当是随手的笔记得了。大概看看原理，不求甚解。

## Fixpoint Theorem

定义函数 $f$ 的不动点 $r$ 为满足 $f(r)=r$ 的所有取值

考虑函数 $f$，定义不动点迭代算法如下：

1. 任取 $X\in D(f)$
2. 计算 $X=f(X)$
3. 重复步骤2 $k$ 次

记出现的所有 $X$ 按顺序构成数列 $\left\{x_n\right\}$，定理如下

若 $f$ 是连续函数，且 $\lim\limits_{n\rightarrow \infty}x_n=r$，那么 $f(r)=r$

证明：

$f(r)=f\left(\lim\limits_{n\rightarrow\infty}x_n\right)=\lim\limits_{n\rightarrow\infty}f(x_n)=\lim\limits_{n\rightarrow\infty}x_{n+1}=r$

根据定义，$r$ 是一个不动点



具体解释就是，当 $k$ 充分大的时候，我们会得到一个充分接近 $r$ 的近似解（极限的定义）



## Convergence Theorem

不动点定理说的是：如果迭代收敛，那么收敛到不动点

收敛定理则给出了迭代收敛的一个充分条件，也就是挑出了一类特殊的可以收敛的函数，给了一个判别条件。



定义 $e_n=\left|x_n-r\right|$，若 $\lim\limits_{n\rightarrow\infty}\frac{e_{n+1} }{e_{n} }=S<1$，那么称这个迭代是线性收敛的，收敛率为 $S$

若函数 $f$ 连续可导，并且 $r$ 是 $f$ 的一个不动点，那么由 $|f'(r)|<1$ 可以推出 $f$ 在以一个足够接近 $r$ 的初值开始迭代时线性收敛，收敛率为 $S$

这句话很难理解，但是结合证明就不太难了：

考虑 $x_{n+1}=f(x_n)$，那么有 $\frac{e_{n+1} }{e_n}=\left|\frac{f(x_n)-r}{x_n-r}\right|=\left|\frac{f(x_n)-f(r)}{x_n-r}\right|=\left|f'(\xi)\right|$，其中 $\xi\in(x_n,r)$，最后一个等号是微分中值定理

取极限就得到了一个 $x=r$ 处的导数，根据条件有这个极限的绝对值小于 $1$

又因为 $f$ 连续可导，所以 $f'$ 连续，所以存在邻域 $U=(r-\delta,r+\delta)$ 使得 $\forall x\in(r-\delta,r+\delta)$ 都有 $|f'(x)|<1$

结合比值就知道，在 $U$ 内任取一个元素作为初值开始迭代，每次的误差会严格递减。又因为误差单调有下界，所以收敛，并且收敛率就是 $|f'(r)|<1$ 的



我们把这类收敛称为局部收敛



具体解释就是，如果函数连续可导并且不动点处的导数比较好，那么存在一个区间 $U$，如果我们在 $U$ 内开始迭代时，就能线性收敛到不动点，并且收敛率是不动点处的导数。

但是定理反过来不成立，意思是一个并非局部收敛的函数可能在别的地方收敛到此，这是完全可行的。

这个定理可以是后验的，即先算出一个收敛的点，然后求导验证是否满足定理前提。



## 根的敏感性

假设 $f$ 的计算存在误差，例如给定 $x$ 时我们只能计算 $f(x)+\epsilon g(x)$，其中 $\epsilon$ 是一个小常数，$g$ 是一个关于 $x$ 的误差函数。那么我们在求根 $r$ 时引入的误差就会进一步被放大。



不妨设求得的数值根为 $r+\Delta r$，那么我们此时求得的实际上是带误差的函数的根，满足
$$
f(r+\Delta r)+\epsilon g(r+\Delta r)=0
$$
两边泰勒展开一下就有
$$
f(r)+\Delta r f'(r) + \epsilon g(r) + \epsilon \Delta r g'(r) + O\left({\Delta r}^2\right)=0
$$
舍去高阶无穷小就是
$$
\Delta r=\frac{-\epsilon g(r)-f(r)}{f'(r)+\Delta r g'(r)}
$$
注意到 $f(r)=0$ 是 $f$ 的根的定义，且 $\Delta r$ 很小，因此上式约为
$$
\Delta r\approx -\epsilon\frac{g(r)}{f'(r)}
$$

          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/07/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%951-%E5%87%BD%E6%95%B0%E6%B1%82%E6%A0%B9/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/13/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9103-%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/13/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9103-%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91/" class="post-title-link" itemprop="url">数理逻辑03 一阶逻辑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-13 12:04:00" itemprop="dateCreated datePublished" datetime="2022-02-13T12:04:00+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:47:11" itemprop="dateModified" datetime="2022-06-19T09:47:11+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          # 写在前面

命题逻辑（或者 零阶逻辑）到一阶逻辑的变化，在于描述的粒度。命题逻辑只能描述命题之间的关系，以及它们如何构成更大的结构（新的命题）。在一阶逻辑中我们可以深入原子命题的内部，讨论命题的构成。



为了做到这一点，需要引入集合上的n元关系。从集合论作为基础的角度看，这么做是比较和谐的。

# 命题逻辑

命题逻辑的不同之处在于，我们既可以描述一个系统内的某些运算（通过函数、变量和常元），又可以描述由这些运算的结果得到的命题（通过谓词和逻辑连接符）。

一个例子就是标准算术模型 $\scr A$：

我们希望能够描述一个系统 $\scr A$，即描述清楚

1. 系统内部存在一些元素（自然数）
2. 这些元素互相可以通过运算（加法、后继）得到新的自然数
3. 可以判断两个元素的大小关系（$<$ 是二元谓词）、相等关系（$=$ 是二元谓词）
4. 可以把若干判断组合成一个更大的判断（通过命题构造子组合命题）

注意到上述4条是有层级的，12位于系统内部，3可以根据需要构造，4在不同的系统中可以完全相同。

## n元关系

定义集合 $D$ 上的n元关系为n元函数 $f\colon D^n\mapsto \left\{T,F\right\}$，取 $P=\left\{x\mid x\in D,f(x)=T\right\}$，那么就可以仅用集合来表示n元关系。

特别的，$<$ 是一个二元关系。它同时是 $\mathbb R,\mathbb N,\mathbb Z$ 上的二元关系，因此可以看出n元关系的定义还要看其定义域，此处即论域

# 语法

记 $\scr P,C,V,F$ 分别为 谓词、常量、变量、函数 符号的可数集，规定每个谓词 $P\in{\scr P}$ 和函数 $F\in{\scr F}$ 都有arity（有多少参数）$\mu(P),\mu(F)\in\mathbb N$。$0$ 元谓词就是命题逻辑中的命题，$0$ 元函数即为常元。

一阶逻辑中仍然存在命题构造子 $\{\wedge,\vee,\rightarrow,\neg\}$，通常取一个完备集即可。

规定**量词** $\forall,\exists$ 分别读作 任意 和 存在

## 项

项集 ${\scr T}$ 由如下递归定义：

1. $\scr C\subseteq T$，常元是项
2. $\scr V\subseteq T$，变量是项
3. $f\in{\scr F},f(t_1,t_2\ldots t_{\mu(f)})\in{\scr T}$，由若干项作为实参的函数作用是项
4. 项仅限于此

所谓的项集就是在描述系统内部的元素，产生新的项的方法只有函数作用。

## 原子公式

形如 $p(t_1,t_2\ldots t_{\mu(p)}),p\in{\scr P}$ 的公式是原子公式

原子公式承担了从项过度到公式（命题）的角色

## 公式

给出BNF
$$
\begin{aligned}
formula &:= atomic\_formula\;|\; \neg formula\;|\;formula\vee formula\;|\;formula\wedge formula
\\
formula &:= \exists x\,formula\;|\;\forall x\,formula
\end{aligned}
$$
一阶逻辑是对命题逻辑的简单拓展，仍然保持了树状结构，之前的证明套路仍然适用。



在一阶逻辑中既然有变量就同样有作用域的问题。具体的定义类似$\lambda$-演算：

1. 公式 $\forall x\, F$，$\exists x\, F$ 中，$x$ 的作用域为公式 $F$，$F$ 不要求有 $x$ 出现
2. 称变量 $x$ 是公式 $F$ 中的自由变量，当且仅当 $x$ 在 $F$ 中出现，且不在限定 $x$ 的任何作用域中。
3. 非自由变量就称其为约束变量。
4. 若公式 $F$ 中，任意变量都是约束变量，则称 $F$ 为封闭公式（Closed Formula），宋公的书叫做句子。



## 替换

和 $\lambda$-演算中的替换是一模一样的



# 语义

命题逻辑的语义由**解释**给出，在一阶逻辑则不够

回忆命题逻辑中解释的定义：$\scr I$ 是函数 $U_A\mapsto \left\{T,F\right\}$，其中 $U_A$ 表示公式 $A$ 中全部原子命题构成的集合

考虑还差了哪些。为了实现类似的效果，我们需要

1. 给常量赋予含义
2. 给变量赋予含义
3. 给项赋予含义
4. 给谓词赋予含义
5. 给原子公式赋予含义



## 解释

宋公的书把这个叫做结构，也行吧。

规定公式 $A$ 的解释是一个三元组 $(D,\left\{R_1\ldots R_m\right\},\left\{d_1\ldots d_k\right\})$

其中 $D$ 是论域，$R_i$ 是论域 $D$ 上的关系，$d_j$ 是 $D$ 中的元素，其赋予了 $A$ 中常量含义。

一个例子是 $\bold 1<\bold 2$ 和 $壹<贰$，此处的 $\left\{壹，贰\right\}$ 都是常量，在规定解释为 $(\mathbb N,\left\{<\right\},\left\{1,2\right\})$ 时才能说等式成立（讨论其真值）。可能存在这么一个神奇的国度，它们把 $1$ 写作 $\bold 2$，把 $2$ 写作 $\bold 1$，那么式1在它们的国度（特定解释下）就不成立了。



但这是不够的。考虑公式 $x<a$，其在任意解释下都不能讨论真值，因为自由变量 $x$ 的值无法确定，由此引入赋值的定义。

## 赋值

记 ${\scr I}_A$ 是公式 $A$ 的解释，$A$ 的赋值 $\sigma_{[{ {\scr I}_A}]}$ 是函数 ${\scr V}\mapsto D$，其赋予了 $A$ 中所有自由变量唯一的论域中的元素作为值。

可以通过类似于 $\sigma_{[{\scr I}_A]}\left\{x\rightsquigarrow v\right\}$ 来对映射进行单点修改，非常熟悉的味道



## 项的语义

base case都很简单，需要注意的只有这么一点：项集是必然可数的，因此项的解释必然是可数的。

大概可以这么理解：对于实数 $\R$，我们必然没法用一阶语言来遍历（穷举）它，因为一阶的语言必然是可数的。

这里就出现了一个gap，我们对任意的项进行解释，不一定能得到整个论域。



## 公式的语义

base case都很简单，需要注意

$\forall x.P$ 的解释为：对于一切 $t\in d$ 都有 $P[\frac{d}{x}]$ 为真。



没了，就这么简单。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/13/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9103-%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/24/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9102-%E6%8E%A8%E6%BC%94%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/24/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9102-%E6%8E%A8%E6%BC%94%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">数理逻辑02 推演系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-24 18:53:00" itemprop="dateCreated datePublished" datetime="2022-01-24T18:53:00+08:00">2022-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:47:11" itemprop="dateModified" datetime="2022-06-19T09:47:11+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          # 写在前面

在上一章给出了命题逻辑的语法、语义，公理化的定义，以及一种判定公式是否可满足/永真的算法，但是这还不够，因为：

1. 并不是所有逻辑都有Decision Procedure，因此这种方法不够普遍
2. 即使有，在有无穷多的公理时，Decision Procedure很可能没法处理无穷项的公式（算法不一定终止）
3. 即使终止，Decision Procedure也只能展示一件事情：命题的真值。我们没法得到中间结果，对理解逻辑没有帮助

于是就有了推演系统（Deductive System），这是对推理证明的形式化。同样的，推演系统有很多种，每一个都有自己的语法（公理+推导规则）和语义（对应逻辑的语义）。在命题逻辑中，不同的一致完备推演系统相互等价，这可以看成是对同一个东西的不同解释（模型）。我们所有的推演都是基于语法的推导，而一致性和完备性则是连接了语法和语义的桥梁，它保证了推演系统足够强大又不会出错。

# 推演系统

包括一组公理集（Set of Axioms）和一组推演规则（Rules of Inference）

## 证明

一个证明（Proof）指的是一段长度有限的公式序列 $A_1,A_2\ldots A_n$，其中每个公式 $A_i,i\in\left\{1\ldots n\right\}$

1. 要么是公理
2. 要么可以由前面的公式+推演规则得到
3. 要么是前面出现过的公式
4. 要么是已经证明过的定理

用 $\vdash A$ 表示 $A$ 在推演系统中可证明，即存在一个证明使得 $A$ 是最后出现的公式，称 $A$ 为一个定理（Theorem）。对于中间出现的公式我们称为引理（Lemma）。

# $\scr G$

给出 Gentzen 系统的（语法）定义

## 公理

含有互补对的公式集是公理

## 推演规则

有两类规则
$$
\frac{\vdash U\cup\left\{\alpha_1,\alpha_2\right\} }{\vdash U\cup\left\{\alpha\right\} }
\\
\frac{\vdash U\cup\left\{\beta_1\right\}\text{\quad}\vdash U\cup\left\{\beta_2\right\} }{\vdash U\cup\left\{\beta\right\} }
$$
一个常见的例子是令 $\alpha=\alpha_1\vee\alpha_2$，$\beta=\beta_1\wedge\beta_2$

在 $\scr G$ 中，一个证明即是一个由公式集组成的序列。

## 正确性

$\scr G$ 的正确性由如下重要定理给出：

设 $\scr U$ 是一个公式集，$\scr \bar U$ 定义为 ${\scr\bar U}=\left\{\bar A\mid A\in{\scr U}\right\}$，那么有 $\vdash {\scr U}$ 当且仅当 ${\scr \bar U}$ 存在closed Semantic Tableaux

该定理的特殊情况是 ${\scr U}=\left\{U\right\}$，此时定理表述为：在 $\scr G$ 中 $\vdash U$ 当且仅当 $\neg U$ 存在closed Semantic Tableaux

### 证明

先证明充分性，即：若 $\scr\bar U$ 存在closed Semantic Tableaux $\scr T$，则 $\vdash\scr U$

考虑对 $\scr T$ 这个树形结构做结构归纳

1. $\scr\bar V$ 是 $\scr T$ 的叶子，则其存在互补对，此时 $\scr V$ 也存在互补对，因此 $\scr V$ 是 $\scr G$ 中的公理，$\vdash\scr V$

2. $\scr\bar V$ 不是 $\scr T$ 的叶子，不妨设 $\scr\bar V$ 中的新增公式为 $\phi$，分类讨论：

   1. $\scr\bar V$ 是一个 Semantic Tableaux 上的 $\alpha$ 推导，则不妨设 $\phi=\alpha_1\wedge\alpha_2$，则其子树 $\scr\bar V'$ 根据归纳假设有 $\vdash\scr V'$，并且有 $\scr\bar V'=\bar V-\left\{\alpha_1\wedge\alpha_2\right\}\cup\left\{\alpha_1,\alpha_2\right\}$。

      此时可得 ${\scr V}={\scr V'}\cup\left\{\neg(\alpha_1\wedge\alpha_2)\right\}-\left\{\neg\alpha_1,\neg\alpha_2\right\}$，再根据 $\scr G$ 中的 $\alpha$ 推导规则就可得到 $\vdash\scr V$。对于 $\phi$ 为其它情况的证明是类似的。

   2. $\scr\bar V$ 是一个 Semantic Tableaux 上的 $\beta$ 推导，则不妨设 $\phi=\beta_1\vee\beta_2$，则其子树 $\scr\bar V_1,\bar V_2$ 根据归纳假设有 $\vdash\scr V_1,\vdash V_2$，并且有 $\scr\bar V_1=\bar V-\left\{\beta_1\vee\beta_2\right\}\cup\left\{\beta_1\right\},\;\bar V_2=\bar V-\left\{\beta_1\vee\beta_2\right\}\cup\left\{\beta_2\right\}$。

      此时可得 ${\scr V}={\scr V_1\cup V_2}\cup\left\{\neg(\beta_1\vee\beta_2)\right\}-\left\{\neg\beta_1,\neg\beta_2\right\}$，再根据 $\scr G$ 中的 $\beta$ 推导规则就可得到 $\vdash\scr V$。对于 $\phi$ 为其它情况的证明是类似的。



再证明必要性，即：若 $\vdash \scr U$，那么 $\scr\bar U$ 存在closed Semantic Tableaux $\scr T$

注意到 $\scr G$ 中的证明本身也有某种树形结构（不过是倒置的），因此也考虑对 $\scr U$ 做结构归纳

1. $\scr U$ 是 $\scr G$ 中的公理，故存在互补对，此时 $\scr\bar U$ 也存在互补对，故 $\scr\bar U$ 必然构造出 $\scr T$
2. $\scr U$ 经推导而来，不妨记新增公式为 $\phi$，记 ${\scr U}={\scr U'}\cup\left\{\phi\right\}$
   1. $\phi = \alpha_1\vee\alpha_2$，此时记前提（Premise）为 $\scr U_1=\scr U'\cup\left\{\alpha_1,\alpha_2\right\}$，必然已有 $\vdash {\scr U_1}$。根据归纳假设有 $\scr\bar U_1$ 存在closed Semantic Tableaux，并且有 ${\scr\bar U} = {\scr \bar U_1}\cup\left\{\neg(\alpha_1\vee\alpha_2)\right\}-\left\{\neg\alpha_1,\neg\alpha_2\right\}$，只需要根据Semantic Tableaux中的 $\alpha$ 推导规则就可以通过 $\scr\bar U_1$ 的Tableaux来得到 $\scr\bar U$ 的Tableaux了。其余形式的 $\phi$ 的证明是类似的。
   2. $\phi = \beta_1\wedge\beta_2$，此时记前提（Premise）为 $\scr U_1=\scr U'\cup\left\{\beta_1\right\},U_2=U'\cup\left\{\beta_2\right\}$，必然已有 $\vdash {\scr U_1},\vdash{\scr U_2}$。根据归纳假设有 $\scr\bar U_1$ 和 $\scr\bar U_2$ 都存在closed Semantic Tableaux，并且有 ${\scr\bar U} = {\scr \bar U_1}\cup{\scr\bar U_2}\cup\left\{\neg(\beta_1\wedge\beta_2)\right\}-\left\{\neg\beta_1,\neg\beta_2\right\}$，只需要根据Semantic Tableaux中的 $\beta$ 推导规则就可以通过 $\scr\bar U_1,\bar U_2$ 的Tableaux来得到 $\scr\bar U$ 的Tableaux了。其余形式的 $\phi$ 的证明是类似的。

回过头看这个证明，无非是把 $\scr G$ 中的每个公式集取反后就对应到了 Semantic Tableaux 上，并且可以发现两个系统里的推导规则可以一一对应。再结合对公式集可满足性的定义就会发现，本质上是对整个公式集组成的大公式做了取反，仅此而已。

### Soundness & Completeness

在 $\scr G$ 中，$\vdash A$ 当且仅当 $\neg A$ 存在closed Semantic Tableaux 当且仅当 $\neg A$ 不可满足 当且仅当 $\models A$

这样就证完了。只需要建立起 $\scr G$ 到 $\scr T$ 的一一对应，就可以利用 $\scr T$ 的一致完备性得到 $\scr G$ 的一致完备性，这正是推演证明的一种。

# $\scr H$

我靠这个花体字实在是太帅了，奈何我怎么都写不出这种感觉。

在 $\scr H$ 中用大写字母表示命题变元（即可带入任意的命题）

下面给出Hilbert 系统的定义

## 公理

$$
\begin{aligned}
\textbf{Axiom 1  } &\vdash A\rightarrow (B\rightarrow A)
\\
\textbf{Axiom 2  } &\vdash (A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow (A\rightarrow C))
\\
\textbf{Axiom 3  } &\vdash (\neg B\rightarrow\neg A)\rightarrow(A\rightarrow B)
\end{aligned}
$$

## 推演规则

只有一条
$$
\frac{\vdash A\;\;\;\vdash A\rightarrow B}{\vdash B}
$$
也叫做肯定前件（modus ponens），记为MP

## 对证明的拓展

设 $\scr U$ 是公式集，$A$ 是某个公式，则符号 ${\scr U}\vdash A$ 表示 $\scr U$ 中的公式是证明 $A$ 的假设

$\scr H$ 中的证明是一系列形如 ${\scr U_i}\vdash A_i$ 的公式，其中 $A_i$ 

1. 要么是公理
2. 要么是已经证明过的引理
3. $A_i\in {\scr U_i}$
4. 可由已经证明过的定理+MP得到

这一拓展反映的是证明形如“如果 $A$ 那么 $B$ ”的命题时，我们可以假设 $A$ 成立，然后检查 $B$ 是否可被证明。

## 衍生规则

虽然只有MP是足够的，但是只用MP就像在裸奔，因此需要包装MP和公理来得到一些更抽象的推演规则。We are now doing composition!

具体可以把这些规则看成是一些语法上的宏，展开就能得到纯MP和公理组成的推演规则。

### Deduction Rule

$$
\frac{  {\scr U}\cup \left\{A\right\}\vdash B}{  {\scr U}\vdash A\rightarrow B}
$$

这条规则就反映了拓展证明的意图，这条规则保证了我们可以在证明 $A\rightarrow B$ 时先假设 $A$，再证明 $B$

下面需要证明拓展是sound的，即不会引入原本不能证明的命题。其completeness是显然的。

对 ${\scr U}\cup\left\{A\right\}\vdash B$ 的推导步骤数 $n$ 作数学归纳法

1. $n=1$，此时 $B$ 一步就得到了，因此 $B$ 要么是公理，要么是 $A$，要么是已经证过的定理，下面给出 $B\neq A$ 的证明：
   $$
   \begin{aligned}
   &{\scr U}\vdash B
   \\
   &{\scr U}\vdash B\rightarrow (A\rightarrow B) &\textbf{Axiom 1}
   \\
   &{\scr U}\vdash A\rightarrow B &\text{MP 1, 2}
   \end{aligned}
   $$
   故sound

   当 $A=B$，该命题退化为 ${\scr U}\vdash A\rightarrow A$

2. $n>1$，因此 ${\scr U}\cup\left\{A\right\}\vdash B$ 是一个MP

   不妨设
   $$
   \begin{aligned}
   &{\scr U}\cup\left\{A\right\}\vdash C
   \\
   &{\scr U}\cup\left\{A\right\}\vdash C\rightarrow B
   \end{aligned}
   $$
   上面两式根据归纳假设有
   $$
   \begin{aligned}
   &{\scr U}\vdash A\rightarrow C &\text{Deduction Rule}
   \\
   &{\scr U}\vdash A\rightarrow (C\rightarrow B) &\text{Deduction Rule}
   \\
   &{\scr U}\vdash (A\rightarrow (C\rightarrow B))\rightarrow ((A\rightarrow C)\rightarrow (A\rightarrow B)) &\textbf{Axiom 2}
   \\
   &{\scr U}\vdash (A\rightarrow C)\rightarrow (A\rightarrow B) &\text{MP 2, 3}
   \\
   &{\scr U}\vdash A\rightarrow B &\text{MP 1, 4}
   \end{aligned}
   $$
   故sound

### Contrapositive Rule

$$
\begin{aligned}
\frac{  {\scr U}\vdash\neg B\rightarrow \neg A}{  {\scr U}\vdash A\rightarrow B}
\end{aligned}
$$

只需要用一下 $\textbf{Axiom 3}$ 就可以得到的规则，注意这条规则和如下规则的区别：
$$
\begin{aligned}
\frac{  {\scr U}\vdash A\rightarrow B}{  {\scr U}\vdash \neg B\rightarrow \neg A}
\end{aligned}
$$
因为我们目前都只在语法层面操作公式，因此二者是有本质区别的规则，需要分别单独证明

### Transitivity Rule

$$
\frac{  {\scr U}\vdash A\rightarrow B\;\;\;\;\;{\scr U}\vdash B\rightarrow C}
{  {\scr U}\vdash A\rightarrow C}
$$

证明如下：
$$
\begin{aligned}
& {\scr U}\vdash A\rightarrow B
\\
& {\scr U}\vdash B\rightarrow C
\\
& {\scr U}\vdash (B\rightarrow C)\rightarrow(A\rightarrow (B\rightarrow C)) &\textbf{Axiom 1}
\\
& {\scr U}\vdash A\rightarrow (B\rightarrow C) &\text{MP 2, 3}
\\
& {\scr U}\vdash (A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow (A\rightarrow C)) &\textbf{Axiom 2}
\\
& {\scr U}\vdash (A\rightarrow B)\rightarrow (A\rightarrow C) &\text{MP 4, 5}
\\
& {\scr U}\vdash A\rightarrow C &\text{MP 1, 6}
\end{aligned}
$$

### Exchange of antecedent Rule

$$
\frac{  {\scr U}\vdash A\rightarrow(B\rightarrow C)}{  {\scr U}\vdash B\rightarrow (A\rightarrow C)}
$$

证明如下：
$$
\begin{aligned}
& \left\{A\rightarrow(B\rightarrow C),A,B\right\}\vdash A\rightarrow(B\rightarrow C)
\\
& \left\{A\rightarrow(B\rightarrow C),A,B\right\}\vdash A
\\
& \left\{A\rightarrow(B\rightarrow C),A,B\right\}\vdash B\rightarrow C
\\
& \left\{A\rightarrow(B\rightarrow C),A,B\right\}\vdash B
\\
& \left\{A\rightarrow(B\rightarrow C),A,B\right\}\vdash C
\\
& \left\{A\rightarrow(B\rightarrow C),B\right\}\vdash A\rightarrow C
\\
& \left\{A\rightarrow(B\rightarrow C)\right\}\vdash B\rightarrow(A\rightarrow C)
\\
& \vdash (A\rightarrow(B\rightarrow C))\rightarrow(B\rightarrow(A\rightarrow C))
\end{aligned}
$$
然后用这条定理对着前件MP一下就好了

### Double negation Rule

$$
\frac{  {\scr U}\vdash\neg\neg A}{  {\scr U}\vdash A},\;\frac{  {\scr U}\vdash A}{  {\scr U}\vdash\neg\neg A}
$$

证明如下：

引理：
$$
\begin{aligned}
& \left\{\neg\neg A\right\}&\vdash& \neg\neg A\rightarrow(\neg\neg\neg\neg A\rightarrow \neg\neg A) &\textbf{Axiom 1}
\\
& \left\{\neg\neg A\right\}&\vdash& \neg\neg A
\\
& \left\{\neg\neg A\right\}&\vdash& \neg\neg\neg\neg A\rightarrow \neg\neg A &\text{MP 1, 2}
\\
& \left\{\neg\neg A\right\}&\vdash& \neg A\rightarrow \neg\neg\neg A &\text{Contrapositive Rule}
\\
& \left\{\neg\neg A\right\}&\vdash& \neg\neg A\rightarrow A &\text{Contrapositive Rule}
\\
& \left\{\neg\neg A\right\}&\vdash& A &\text{MP 2, 5}
\\
& &\vdash& \neg\neg A\rightarrow A &\text{Deduction Rule}
\end{aligned}
$$
因此
$$
\begin{aligned}
& {\scr U}\vdash \neg\neg A
\\
& {\scr U}\vdash \neg\neg A\rightarrow A
\\
& {\scr U}\vdash A
\end{aligned}
$$
另一个的证明是类似的

### Reductio ad absurdum

也就是所谓的排中律

即
$$
\frac{  {\scr U}\vdash \neg A\rightarrow false}{  {\scr U}\vdash A}
$$




规定 $false \overset{def}=A\wedge\neg A\overset{def}=\neg(A\rightarrow A)$，$true\overset{def}=A\vee\neg A\overset{def}=A\rightarrow A$，注意这是语法上的定义，即两侧可以等价替换。

那么有 $\vdash \neg false$，且 $\vdash true$，这个证明是显然的。



关于排中律的"证明"：
$$
\begin{aligned}
& {\scr U}\vdash \neg A\rightarrow false
\\
& {\scr U}\vdash \neg false\rightarrow \neg\neg A &\text{Contrapositive Rule}
\\
& {\scr U}\vdash \neg false &\text{By Lemma}
\\
& {\scr U}\vdash \neg \neg A &\text{MP 2, 3}
\\
& {\scr U}\vdash A &\text{Double negation Rule}
\end{aligned}
$$


在某些逻辑里，$\vdash A\vee\neg A$ 是可以不成立的。比如说Constructive Logic里就没法通过反证法证明一个东西，你必须提供一个构造才能说明某些存在性。在这里不是重点

### Commutativity

$$
\vdash A\vee B\rightarrow B\vee A
$$

 在 $\scr H$ 中没有对 $\vee \wedge$ 的直接讨论，通常通过定义 $A\vee B\overset{def}= \neg A\rightarrow B$ 和 $A\wedge B\overset{def}= \neg(A\rightarrow \neg B)$ 来将其转化为 $\neg \rightarrow$ 符号集上的证明。这也说明了 $\left\{\neg,\rightarrow\right\}$ 是完备集

交换律的证明是简单的，但是后面 $\scr H$ 的正确性证明需要用到这个。

### Weakening

$$
\begin{aligned}
&\vdash A\rightarrow A\vee B
\\
&\vdash A\rightarrow B\vee A
\\
&\vdash (A\rightarrow B)\rightarrow((C\vee A)\rightarrow(C\vee B))
\end{aligned}
$$

证明也是简单的，只需要按定义换掉 $\vee$ 就可以了，第三条是MP的简单应用

### Associativity

$$
\begin{aligned}
&\vdash A\vee(B\vee C)\rightarrow (A\vee B)\vee C
\\
&\vdash (A\vee B)\vee C\rightarrow A\vee(B\vee C)
\end{aligned}
$$

证明需要用一下交换律，然后推就好了

### Distributivity

$$
\begin{aligned}
&\vdash A\vee(B\wedge C)\leftrightarrow (A\vee B)\wedge (A\vee C)
\\
&\vdash A\wedge(B\vee C)\leftrightarrow (A\wedge B)\vee (A\wedge C)
\end{aligned}
$$

这里规定 $\vdash A\leftrightarrow B$ 当且仅当 $\vdash A\rightarrow B$ 且 $\vdash B\rightarrow A$

这里是 $\scr H$ 中语法上的De morgan Law，在没有证明 $\scr H$ 的正确性之前是不能由语义上得到的。

这个本菜菜还没想到要怎么证，好像也没找到要怎么证/(ㄒoㄒ)/

## $\scr H$ 的正确性

### Soundness

对于 $A\in{\scr H}$，若 $\vdash A$，那么 $\models A$

即证明所有 $\scr H$ 可证明的公式都永真，只需要对 $A$ 的证明步骤数 $n$ 做归纳即可。这里可以仅考虑原始的三条公理+MP的 $\scr H$，因为所有后面的定理和规则都可以规约回去。

1. $n=1$，此时 $A$ 是三公理之一，构建 $\neg A$ 的Semantic Tableaux即可发现都是closed的，因此 $\models A$
2. $n>1$，此时 $A$ 经由MP得到，前面必然有 $\vdash B\rightarrow A$，$\vdash B$。根据归纳假设有 $\models B\rightarrow A$，$\models B$，根据 $\rightarrow $ 的语义即得 $\models A$。注意我们这里在讨论 $\models$，因此可以用语义上的定义来进行证明。

### Completeness

对于 $A\in{\scr H}$，若 $\models A$，那么 $\vdash A$。注意到 $\scr G$ 是sound&complete的，因此可以通过 $\scr G$ 作为媒介证明

引理1：若 $\vdash{\scr U}$ in $\scr G$，那么 $\vdash \bigvee{\scr U}$ in $\scr H$

理解引理1是很简单的，只需要注意到 $\scr G$ 中的定理是一个隐含的 $\bigvee$ 公式，同时结合 $\vdash A$ 当且仅当 $\models A$ in $\scr G$ 就好了。



引理2：若 ${\scr U'}\subseteq{\scr U}$，$\vdash \bigvee{\scr U'}$ in $\scr H$，那么 $\vdash\bigvee{\scr U}$ in $\scr H$

之所以提出引理2是因为我们很难直接获得整个公式集 $\scr U$ 构成的公式在 $\scr H$ 中的推导。但是注意到 $\scr G$ 中的公理都有互补对，而互补对是我们可以在 $\scr H$ 中推导的，因此考虑证明这个弱化前提的引理2。



引理3：$\vdash A\rightarrow(B\rightarrow A\wedge B)$



引理2的证明：

由 $\vdash\bigvee{\scr U'}$，可以得到 $\scr H$ 中的一个证明。又根据 Weakening Theorem，可以将 $\scr U-\scr U'$ 中的公式一个个加上得到 $\vdash\bigvee{\scr U''}$，其中 $\bigvee\scr U''$ 是 $\bigvee\scr U$ 的一个排列，这一步可以对 $|\scr U-U'|$ 作数学归纳法。

又根据 Commutativity Theorem可以交换 $\bigvee\scr U''$ 中的任意两个相邻的公式，因此可以排序得到 $\vdash\bigvee\scr U$，这一步可以给公式编号，然后对逆序对作数学归纳法。

引理1的证明可以对 $\scr U$ 在 $\scr G$ 中的推导用结构归纳法：

1. $\scr U$ 是 $\scr G$ 中公理，因此存在 ${\scr U'}=\left\{p,\neg p\right\}\subseteq{\scr U}$。此时显然有 $\vdash\bigvee \scr U'$ in $\scr H$，根据引理2就有 $\vdash\bigvee \scr U$ in $\scr H$

2. $\scr U$ 在 $\scr G$ 中经过至少一步推导得到，不妨记新增公式为 $\phi$，记 ${\scr U}=\left\{\phi\right\}\cup {\scr V}$

   1. $\phi=\alpha_1\vee\alpha_2$，记 ${\scr U_1}={\scr V}\cup\left\{\alpha_1,\alpha_2\right\}$，则根据归纳假设有 $\vdash\bigvee{\scr U_1}$ in $\scr H$，也就是 $\vdash(\bigvee{\scr V})\vee\alpha_1\vee\alpha_2$。根据 Associativity Theorem即得 $\vdash(\bigvee{\scr V})\vee(\alpha_1\vee\alpha_2)$，也就是 $\vdash\bigvee\scr U$ in $\scr H$

   2. $\phi=\beta_1\wedge\beta_2$，记${\scr U_1}={\scr V_1}\cup\left\{\beta_1\right\}$，记 ${\scr U_2}={\scr V_2}\cup\left\{\beta_2\right\}$，则根据归纳假设有 $\vdash\bigvee{\scr U_1},\;\vdash\bigvee{\scr U_2}$ in $\scr H$，也就是 $\vdash(\bigvee{\scr V_1})\vee\beta_1,\;\vdash(\bigvee{\scr V_2})\vee\beta_2$
      $$
      \begin{aligned}
      & \vdash \bigvee{\scr V_1}\vee\beta_1 
      \\
      & \vdash \neg\bigvee{\scr V_1}\rightarrow \beta_1&\text{By Definition of $\vee$}
      \\
      & \vdash \beta_1\rightarrow(\beta_2\rightarrow\beta_1\wedge\beta_2)&\text{Lemma 3}
      \\
      & \vdash \neg\bigvee{\scr V_1}\rightarrow(\beta_2\rightarrow \beta_1\wedge\beta_2)&\text{By Transitivity}
      \\
      & \vdash \beta_2\rightarrow(\neg\bigvee{\scr V_1}\rightarrow\beta_1\wedge\beta_2)&\text{Exchange of Antecedent Rule}
      \\
      & \vdash \bigvee{\scr V_2}\vee\beta_2&\text{}
      \\
      & \vdash \neg\bigvee{\scr V_2}\rightarrow\beta_2&\text{By Definition of $\vee$}
      \\
      & \vdash \neg\bigvee{\scr V_2}\rightarrow(\neg\bigvee{\scr V_1}\rightarrow\beta_1\wedge\beta_2)&\text{By Transitivity}
      \\
      & \vdash (\bigvee{\scr V_2})\vee(\bigvee{\scr V_1})\vee(\beta_1\wedge\beta_2)&\text{By Definition of $\vee$}
      \end{aligned}
      $$
      这样就证明了 $\vdash \scr U$ in $\scr H$

最后考虑怎么证明 $\models A$ 则 $\vdash A$ in $\scr H$

构造 ${\scr U}=\left\{A\right\}$，$\models A$ 当且仅当 $\vdash \scr U$ in $\scr G$ 当且仅当 $\vdash \bigvee\scr U$ in $\scr H$ 当且仅当 $\vdash A$ in $\scr G$

于是就证明了 $\scr H$ 是Sound & Complete的

# 一致性

称公式集 $\scr U$ 是**不一致**的，当且仅当存在公式 $A$ 使得 ${\scr U}\vdash A$ 并且 ${\scr U}\vdash \neg A$

称 $\scr U$ 是一致的，当且仅当它不是不一致的



若 $\scr U$ 是不一致的，那么对于任意公式 $A$ 都有 ${\scr U}\vdash A$

证明就不写了咕咕咕咕

由此可以得到一个很有用的定理，${\scr U}\vdash A$ 当且仅当 ${\scr U}\cup\left\{\neg A\right\}$ 不一致

后面还有一些关于可数无穷多个公式的真值的讨论，还是咕咕咕咕

这样这一章就讲完啦
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/24/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9102-%E6%8E%A8%E6%BC%94%E7%B3%BB%E7%BB%9F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E4%B9%A0%E9%A2%98%E4%B9%B1%E5%81%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/21/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E4%B9%A0%E9%A2%98%E4%B9%B1%E5%81%9A/" class="post-title-link" itemprop="url">数理逻辑习题乱做</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-21 23:44:00" itemprop="dateCreated datePublished" datetime="2022-01-21T23:44:00+08:00">2022-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          做习题，不保证对，不保证全

## 2.10

证明只有 $\uparrow,\downarrow$ 能单独定义所有的单目和二元运算

首先考虑如何表示 $\neg$。

$\circ$ 这个二元运算能表示 $\neg$ 的定义为，对于任意公式 $A$ 都有 $\neg A=A\circ A\circ A\cdots A$ 成立

取解释 $\scr I$ 使得 ${\scr I}(A)=T$，代入上式有 $F=T\circ T\circ T\cdots T$

这里可以发现，对于 $\circ$ 运算必然有 $T\circ T=F$ 成立。否则假设 $T\circ T=T$，那么简单归纳就有 $F=T\circ T\circ T\cdots T=T$，矛盾。

同理可以知道必然有 $F\circ F=T$。那么就可以知道 $\circ$ 只能是 $\uparrow$，$\downarrow$，投影，投影取反

假设 $\circ$ 是投影，那么根据投影的性质简单归纳可知投影的复合还是投影，这就与它能表示任意二元运算矛盾了。投影取反同理。因此就只能是 $\uparrow,\downarrow$

然后可以构造 $A\uparrow A=\neg A$，$(A\uparrow B)\uparrow(A\uparrow B)=\neg(A\uparrow B)=A\and B$，这样就实现了一个完备集，搞定！



## 2.11

证明 $\wedge$ 和 $\vee$ 不是完备符号集

很显然单个的 $\wedge$ 和 $\vee$ 不是完备集（参照2.10），下面证明 $\left\{\wedge,\vee\right\}$ 不是完备集

类似上面的证明，取 $\neg A=A\wedge A\vee A\cdots A$，右侧可以任意加减括号

取解释 $\scr I$ 使得 ${\scr I}(A)=T$，那么有 $F=T\wedge T\vee T\cdots T=T$，矛盾。



## 2.12

证明 $\left\{\neg,\leftrightarrow\right\}$ 不是完备集

考虑某个投影运算 $\circ$，其定义为 $A\circ B=A$，那么假设这是一个完备集，根据定义有

$A\circ A=(A\leftrightarrow A)\leftrightarrow\neg(\cdots$

考虑公式的所有二元运算的叶子：

1. 形如 $A\leftrightarrow A$，其与 $\top$ 逻辑等价，值为 $T$
2. 形如 $\neg A\leftrightarrow A$，其与 $\bot$ 逻辑等价，值为 $F$
3. 形如 $A\leftrightarrow\neg A$，其与 $\bot$ 逻辑等价，值为 $F$
4. 形如 $\neg A\leftrightarrow \neg A$，其与 $\top$ 逻辑等价，值为 $T$

即上述等式的右侧将会是一个常量（$T$ 或 $F$），即 $A\circ A=T$ 或 $A\circ A=F$，二者只能取其一。

然而根据投影的定义有 $A\circ A=A=T$，在使得 $A$ 为 $F$ 的解释下就找到了一个矛盾，因此这不是完备集。



## 2.17

设 $\scr U$ 是一个公理集，记 ${\scr T}(\scr U)$ 是其导出的理论集，证明 $\scr T(U)$ 在 $\models$ 下是封闭的。

由反证法假设其不封闭，则存在 $A\not\in {\scr T(U)}$，满足 ${\scr T(U)}\models A$，即 $\models \bigwedge{\scr T(U)}\rightarrow A$。

根据 $\scr T(U)$ 的定义有 $\forall F\in{\scr T(U)}$ 都有 ${\scr U}\models F$，即对于任意 $\scr T(U)$ 中的公式 $F$ 都有 $\models \bigwedge{\scr U}\rightarrow F$，因此有 $\models \bigwedge{\scr U}\rightarrow \bigwedge{\scr T(U)}$

结合上面两条就有 $\models \bigwedge{\scr U}\rightarrow A$，即 ${\scr U}\models A$，根据 $\scr T(U)$ 的定义有 $A\in{\scr T(U)}$，这与假设矛盾；故假设不成立，即 $\scr T(U)$ 在 $\models$ 下封闭



## 3.18

称公式集是极大一致的，当且仅当它的所有真超集都是不一致的。设 $S$ 是一极大一致的可数公式集，证明：

1. $S$ 的所有有限子集都是可满足的
2. 对于任意公式 $A$，$S\cup\left\{A\right\}$ 和 $S\cup\left\{\neg A\right\}$ 二者至少有一个是一致的
3. $S$ 可以被拓展为极大一致的公式集



### 1

显然对于公式集 $S$ 的有限子集 $T$，$T$ 是一致的（否则将得出 $S$ 不一致的矛盾）

由反证法，设 $T$ 不可满足，则任意解释下 $T$ 中存在值为 $F$ 的公式。因此根据 $\models$ 的定义，对于任意的公式 $A$ 都有 $T\models A$，即 $\models \bigvee T\rightarrow A$

又根据 $\scr H$ 的可靠性和完备性有 $\vdash \bigvee T\rightarrow A$，即 $T\vdash A$ 对任意公式 $A$ 都成立。因此 $T$ 不一致，这与假设矛盾。故 $T$ 可满足。

中间跳了一些步骤

### 2

假设都不一致，那么有 $S\vdash A$ 并且 $S\vdash\neg A$，根据定义有 $S$ 不一致，与假设矛盾。故 至少有一个是一致的

### 3

注意到 $S\cup \left\{A\right\}$ 和 $S\cup\left\{\neg A\right\}$ 二者至少有一个保持了一致性，并且2中的证明只用到了 $S$ 的一致性，所以用2中的结论一直往里面加公式就好了，这样就会得到 $\forall A\in{\scr F}\text{, either $A\in S$ or $\neg A\in S$}$



## Prob 1

证明 $|PROP|=\aleph_0$

### 证明1

构造 $P_k=\overbrace{PS\times PS\times\cdots PS}^{k个}$，其中 $PS\times PS$ 定义为集合的笛卡尔积运算

定义 $P=\bigcup_{k\in\mathbb N^+} P_k$，有 $PROP\subseteq P$

并且对于任意正整数 $k$，有 $P_k$ 是可数集，因此 $P$ 是可数个可数集之并，易证 $|P|=\aleph_0$，因此 $|PROP|\leqslant\aleph_0$

又注意到如下命题构造序列：$A,\neg A,\neg\neg A\ldots$，易得 $|PROP|\geqslant\aleph_0$

结合就有 $|PROP|=\aleph_0$

### 证明2

考虑构造如下映射 $f$：
$$
\begin{equation}
f(x)=\left\{
\begin{aligned}
0002&,&   x&=\neg\\
0012&,&   x&=\wedge\\
0102&,&  x&=\vee\\
0112&,&  x&=\rightarrow\\
1002&,& x&=(\\
1012&,& x&=)\\
bit(x)0002&,& x&\in PS\\
\end{aligned}
\right.
\end{equation}
$$
其中 $bit(x)$ 将自然数 $x$ 转化为其二进制表示的字符串。

很显然 $f:PROP\mapsto \mathbb N$ 是一个单射，这里可以把结果串解释为三进制数，故有 $|PROP|\leqslant\aleph_0$

另一个不等式是显然的



## Prob 2

证明括号引理

其实就是结构归纳的简单应用。

### Base Case

考虑 $A\in PS$，此时左括号的数量等于右括号的数量

### Step Case

1. $A=(\neg B)$，而 $B$ 是命题，则根据归纳假设 $B$ 满足括号引理，因此 $A$ 仍然满足
2. $A = (B\wedge C)$，根据归纳假设 $B,C$ 满足括号引理，此时 $A$ 仍然满足
3. 剩下的几个是类似的

根据结构归纳法，所有由上述方法定义出的命题都满足括号引理。又因为命题仅限于此，因此对于所有的命题括号引理都成立。证毕。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/21/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E4%B9%A0%E9%A2%98%E4%B9%B1%E5%81%9A/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/20/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9101-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/20/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9101-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/" class="post-title-link" itemprop="url">数理逻辑01 命题逻辑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-20 18:31:00" itemprop="dateCreated datePublished" datetime="2022-01-20T18:31:00+08:00">2022-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:47:11" itemprop="dateModified" datetime="2022-06-19T09:47:11+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          # 写在前面

第一次看这本书的时候看得比较急，也没有一个big picture的把握，所以在细节上面耗费了很多时间....现在算是重构一次笔记了

我们知道，形式逻辑是对推理的形式化（mathematical logic formalizes resoning），为了描述推理我们有各种各样的逻辑系统。对于一个逻辑系统，最关键的就是它的语法（Syntax）和语义（Semantics）。其中语法决定了逻辑系统中讨论的对象长什么样，而语义决定了我们如何解释这些逻辑系统中被研究的对象。

比如说我们有研究命题的命题逻辑（Propositional Logic）、包含了函数 算术的一阶逻辑（First Order Logic）、对真值进行扩充得到的模态逻辑等等。这些逻辑的区别就在于它们的语法和语义。

同时，在熟悉这些逻辑系统的同时，还要分清什么是我们的研究对象。因为逻辑在研究推理的形式化，因此需要区分什么是逻辑系统中的形式化推理（研究对象），什么是我们对于研究对象的推理。后者被成为元逻辑、元语言，前者就是对象逻辑、对象语言了。所有的对象逻辑都应根据相应的逻辑系统的定义赋予其含义，而在元语言的层面则可以随意一些，就是正常的平时推理。

本书是写给CSer的数理逻辑教材，因此会专门讲不同逻辑系统中的一类算法（Decision Procedure）的构造和正确性证明，这些是纯数不太感兴趣的东西，也是这本书多出来的东西。同时在看的时候，还要尤其注意什么是基础、什么是组合构造方法、这些逻辑对哪些东西做了抽象，这三板斧应该刻在DNA里。

废话不多说



# 命题逻辑

命题逻辑是比较常见易懂的逻辑，它主要关心在给出若干基本命题（atoms）之后，如何通过组合小命题来获得大命题、如何给组合命题递归地赋予含义（Compositionality），因此用树形结构来展示这样的命题构造就是很自然的了。

## 语法

给出BNF
$$
{stmt = atom\;|\;(\neg\;stmt)\;|\;(stmt_1\;op\;stmt_2)}
$$
为了方便，引入语法符号 $\top,\bot$，规定任意解释下都有 ${\mathscr I}(\bot)=F,{\mathscr I}(\top)=T$

通常记所有公式组成的集合为 $\mathscr F$

## 语义

定义公式 $A$ 的一个解释 $\mathscr I$ 为一个函数 $U_A\mapsto \left\{T,F\right\}$，其中 $U_A$ 为公式 $A$ 中包含的所有原子所组成的集合

通过 ${\mathscr I}(A_1)$ 和 ${\mathscr I}(A_2)$ 给出 ${\mathscr I}(A_1\;op\;A_2)$ ，以此来定义命题构造子（别人都叫他运算符，但我更喜欢这么说）$op$ 的含义



若在某个解释 $\scr I$ 下公式 $A$ 满足 ${\scr I}(A)=T$，我们就说 $A$ 是可满足的（satisfiable），此时的 ${\scr I}$ 是 $A$ 的一个模型（Model）

若在任意解释 ${\scr I}$ 下公式 $A$ 满足 ${\scr I}(A)=T$，我们就说 $A$ 是永真的（valid），记作 $\models A$

类似可以定义永假的（即不可满足的 unsatisfiable）、可假的（fasifiable）记作 $\not\models A$，在某些操作下这四种性质可以互相转化



需要注意的是，我们在命题逻辑中讨论的全都是命题变元（语法上的公式），而赋予其真值是解释做的事情（语义上的含义）。这也是为什么我没有通过给“运算符”列真值表来定义，这里的定义完全是基于解释的。

## 定义和定理

### 公式组成的集合的解释

记 ${\scr U}=\left\{A\right\}$ 为公式的集合（在这里我们忽略无穷集，因为对于无穷的二元运算没有定义）

若在某个解释 ${\scr I}$ 下有 ${\scr I}(A)=T$ 对 ${\scr U}$ 中的每个公式都成立，则称 ${\scr U}$ 是可满足的

若在任意解释 ${\scr I}$ 下都存在 ${\scr U}$ 中的某个公式 $A$ 使得 ${\scr I}(A)=T$，则称 ${\scr U}$ 是不可满足的

容易发现这个定义就是在讨论 $\bigwedge_{A\in {\scr U} } A$ 在解释 ${\scr I}$ 下的真值

### 运算符

一个 $n$ 元运算实际上是 $\left\{T,F\right\}^n\mapsto \left\{T,F\right\}$ 的一个函数，因此有 $\scr F$ 上的本质不同的 $n$ 元运算有 $2^{2^n}$ 种。

在结构归纳法中我们需要讨论所有形式的公式（即，在每一种运算下产生的所有公式），非常麻烦。一种想法是找出尽可能基本的运算，在此之上构造剩余的运算。



定义运算 $\circ$ 能被 $O=\left\{\circ_1,\circ_2\ldots\circ_n\right\}$ 表示，当且仅当对于任意 $\scr F$ 中的公式 $A,B$，都有 $A\circ B=C_X\circ_Y C_X\cdots C_X$

其中 $C_X\in\left\{A,B\right\}$，$\circ_Y\in O$

特殊地，对于单目运算符 $\sim$，我们修改定义为 $\sim A=A\circ_Y A\cdots A$，其中 $\circ_Y\in O$



定义运算集 $O$ 是完备的（Adequate），当且仅当所有运算都可被 $O$ 表示。学过数电都知道 NAND和NOR 可以搭出所有电路，在逻辑系统中也有这样的性质，证明只需要简单的构造一下就好了。常用的完备集是 $\left\{\wedge,\vee,\neg\right\}$



定理：二元运算的最小完备集只可能是 $\uparrow$ 或 $\downarrow$，即NAND或NOR。具体的证明可以看后面的习题合辑（如果我没有咕咕咕的话）

### 等价、逻辑后承

定义 $\mathscr F$ 上的二元关系 $\equiv$ 逻辑等价（Logical Equivalence）为：

$A_1\equiv A_2$ 当且仅当在任意解释下，有 ${\mathscr I}(A_1)={\mathscr I}(A_2)$



定义逻辑后承（Logical Consequence）的含义为：

${\scr U}\models A$ 当且仅当在所有使得 ${\scr U}$ 可满足的解释 $\scr I$ 下，都有 ${\scr I}(A)=T$

我个人觉得也可以叫语义后承



$A\leftrightarrow B$ 永真当且仅当 $A\equiv B$

$\bigwedge_{A\in {\scr U} }A\rightarrow B$ 永真 当且仅当 ${\scr U}\models B$

这两个定理实际上是为命题逻辑系统中的语法符号作出了解释，即我们可以用一些逻辑系统内部满足的性质来代替元语言的描述

### 子公式、替换

子公式仍然是 $\scr F$ 上的二元关系，在不影响上下文理解的时候，我们将把 $A$ 是 $B$ 的子公式简记作 $A\subseteq B$

子公式的严格定义可以通过公式作为树结构导出，只需要照抄子树的定义就好

同样在树结构上操作，我们可以将一棵子树替换为另一棵子树，在公式中就表现为将一段子公式替换为另一个公式，记作 $A\left\{B\leftarrow C\right\}$，其中 $B\subseteq A$，解释为 把 $A$ 中的**所有**子公式 $B$ 替换为公式 $C$



若 $B\equiv C$ 且 $B\subseteq A$，则有 $A\left\{B\leftarrow C\right\}\equiv A$ 成立

具体的证明可以通过对树形结构来归纳做。

### 文字、互补对

这个翻译很怪

对于原子 $p$，我们把 $p$ 和 $\neg p$ 称为一对文字（Literals），其中 $p$ 是正文字（Positive），$\neg p$ 是负的（Negative）

同一个原子的两个文字组成一对互补对（Complementary Pair）



若公式集 ${\scr U}$ 存在一对互补对，即存在 $p,\neg p\in {\scr U}$，当且仅当 ${\scr U}$ 不可满足

这是由定义即得的。互补对定理使得我们可以构造出一种正确的Decision Procedure

### 理论

若公式集 $\scr F$ 在 $\models$ 二元关系下满足封闭性，则称 $\scr F$ 是一个理论（Theory），$\scr F$ 中的公式为定理（Theorem）

对于一个理论 $\scr F$，若存在 $\scr U\subseteq F$ 使得 ${\scr F=}\left\{A|{\scr U}\models A\right\}$，则称 $\scr F$ 是可公理化的（Axiomatizable），$\scr U$ 是 $\scr F$ 的一组公理。

需要注意的是，这里对公理集的大小没有限制。考虑皮亚诺公理系统，我们对自然数集中的每个元素都作出了公理化的定义，因此皮亚诺公理系统的公理集合实际上是由一个Axiom Scheme产生的，我们把这个单独的Scheme作用到每个元素上就得到了无穷多个公理。

### Decision Procedure

对于 $\scr F$ ，一个算法 ${\scr F}\mapsto \left\{T,F\right\}$ 被称为是一个Decision Procedure。记使其输出为 $T$ 的公式集合为 $\scr U$，显然有 $\scr U\subseteq F$，我们称这个算法是 Decision Procedure on $\scr U$

通常我们会关注 Decision Procedure on Validity，即给定一个公式判断它是否永真

## Semantic Tableaux

ST是一种Decision Procedure，它能判定一个公式是否可满足

### 构造

1. 令根节点的标记为由待判定的公式 $A$ 组成的集合 $\left\{A\right\}$，记为 $label(l)=\left\{A\right\}$
2. 选取一个未被标记为open或closed的叶子 $l$，若不存在则前往步骤8
3. 若 $label(l)$ 全是文字，则如果存在互补对，就标记为closed leaf并回到步骤2；如果不存在就标记为open leaf并回到步骤2。如果不全是文字，则前往步骤4
4. 记 $label(l)$ 中不是文字的公式为 $W$
5. 若 $W$ 形如 $A_1\wedge A_2$，则构造 $l$ 的儿子 $l'$，其标记为 $label(l')=label(l)-\left\{W\right\}+\left\{A_1,A_2\right\}$，回到步骤2
6. 若 $W$ 形如 $A_1\vee A_2$，则构造 $l',l''$，其中 $label(l')=label(l)-\left\{W\right\}+\left\{A_1\right\}$，$label(l'')=label(l)-\left\{W\right\}+\left\{A_2\right\}$，回到步骤2
7. 若 $W$ 形如 $\neg A$，则根据De Morgan Law化进去，回到4
8. 如果所有叶子都是closed，则称这棵树也是closed的，输出不可满足；否则称这棵树是open的，输出可满足

### Termination

记公式 $A$ 所含二元运算的数量为 $b(A)$，单目运算数量为 $s(A)$，定义 $b({\scr U})=\sum\limits_{u\in{\scr U} }b(u)$，$s({\scr U})=\sum\limits_{u\in{\scr U} }s(u)$

对于节点 $l$，构造其势能函数为 $W(l)=b(label(l))+s(label(l))$，则有如下性质：

1. 任意树上的节点 $l$ 都有 $W(l)\geqslant 0$。这是因为 $b(\cdot),s(\cdot)$ 都是非负的
2. 任意树上的节点 $l$ 及其子节点 $l',l''$，都有 $W(l)> W(l'),W(l)> W(l'')$。这个只需要针对步骤5、6、7分别讨论就好了

因此上述构造必然终止。并且因为必然终止，所以每个叶子要么open，要么closed

### 正确性

对于Decision Procedure的正确性要分成Soundness和Completeness两方面证明

#### Soundness

即证明：如果Semantic Tableaux closed，那么公式不可满足

即证明：如果算法claim公式 $A$ 是不可满足的，那么 $A$ 确实是不可满足的

#### Completeness

即证明：如果公式不可满足，则所有的Semantic Tableaux都closed

即证明：如果公式 $A$ 不可满足，则上述算法构造出来的所有Semantic Tableaux都closed，算法永远claim $A$ 不可满足

证明就咕咕咕啦。这样，这一章就看完啦

### Compactness

讨论的是任意大小的公式集 $\scr U$ 的可满足性

定义使得性质 "任意 ${\scr S}\subseteq {\scr U}$ 若 $|{\scr S}|\in\mathbb N$ 那么 ${\scr S}$ 可满足" 成立的集合 $\scr U$ 为有限可满足公式集。有限可满足的公式集的所有有限子集都可满足。那么有定理：若 $\scr U$ 有限可满足，那么 $\scr U$ 仍然可满足。



首先取有限可满足集 $\Gamma_0$。注意到公式集 $\scr F$ 是可数集，因此可以构造公式序列  ${\scr F}=\left\{F_1,F_2,F_3\ldots\right\}$

定义若 $\Gamma_{n}\cup\{F_{n+1}\}$ 可满足，那么 $\Gamma_{n+1}=\Gamma_n\cup\{F_{n+1}\}$，否则 $\Gamma_{n+1}=\Gamma_{n}\cup\{\neg F_{n+1}\}$



有如下claim：$\Gamma_n$ 的存在性对于任意的正整数 $n$ 成立。由反证法，假设存在最小的 $n'$ 使得 $\Gamma_{n'}\cup\{F_{n'+1}\}$ 与 $\Gamma_{n'}\cup\{\neg F_{n'+1}\}$ 都不是有限可满足公式集，则根据定义存在 $\Delta_1,\Delta_2\subseteq \Gamma_{n'}$ 使得 $\Delta_1\cup\{F_{n'+1}\}$ 与 $\Delta_2\cup\{\neg F_{n'+1}\}$ 都不是可满足的。又因为 $\Delta_1,\Delta_2$ 是 $\Gamma_{n'}$ 的子集，且 $\Gamma_{n'}$ 有限可满足，因此存在解释 $\scr I$ 使得 ${\scr I}\models \Delta_1\cup\Delta_2$

取这个解释

1. 若 ${\scr I}\models F_{n'+1}$，那么 ${\scr I}\models \Delta_1\cup\{F_{n'+1}\}$
2. 若 ${\scr I}\models \neg F_{n'+1}$，那么 ${\scr I}\models\Delta_2\cup\{\neg F_{n'+1}\}$

无论如何都与假设矛盾，因此假设不成立；



此时再构造 $\Delta=\bigcup\limits_{i=0}^{\infty} \Gamma_{i}$，则任取 $\Delta$ 的有限子集 $S$，其中都存在下标最大的公式 $F_{max}\in S$，那么根据定义有 $S\subseteq\Gamma_{max}\subseteq\Delta$。由 $\Gamma_{max}$ 有限可满足即得 $S$ 有限可满足。由 $S$ 的任意性即得 $\Delta$ 有限可满足



此时取所有原子命题的集合 ${\scr P}$，有 ${\scr P}$ 中的任意原子 $p$，要么 $p\in\Delta$，要么 $\neg p\in\Delta$，且二者不同时成立。

不同时成立只需要反证一下，结合 $\Delta$ 有限可满足，且 $\{p,\neg p\}$ 不可满足就能得到

同样反证 $p\not\in\Delta$ 且 $\neg p\not\in\Delta$，由 $p\in{\scr F}$ 可知存在自然数 $k$ 使得 $F_k=p$，构造一下 $\Gamma_{k+1}$ 就会发现必然有 $p\in\Gamma_{k+1}$ 或 $\neg p\in\Gamma_{k+1}$，由$\in$ 符号的传递性即得 $p\in\Delta$ 或 $\neg p\in\Delta$



对 $\Delta$ 中出现的原子进行 $\scr I$ 的构造：

1. 若 $p\in\Delta$，那么 ${\scr I}(p)=T$
2. 否则必然有 $\neg p\in\Delta$，此时规定 ${\scr I}(p)=F$



下面证明 ${\scr I}\models \Delta$，只需要对 $\Delta$ 中的公式做结构归纳即可。其实可以证明一个更强的结论：$A\in\Delta$ 当且仅当 $\models A$

命题对原子命题显然成立；

考虑 $A=\neg B$ 形式的命题 $A$：

1. 由 $A=\neg B\in\Delta$ 可得 $B\not\in\Delta$，故 ${\scr I}\not\models B$，即 ${\scr I}\models\neg B$，即 ${\scr I}\models A$
2. 若 $A=\neg B\not\in\Delta$，那么 $B\in\Delta$，故 ${\scr I}\models B$，即 ${\scr I}\not\models\neg B$，即 ${\scr I}\not\models A$

考虑 $A=B\wedge C$ 形式的命题 $A$：

必然有 $B,C\in\Delta$，否则不妨假设 $B\not\in\Delta$，则 $\{\neg B,A\}\subseteq\Delta$，此时 $\{\neg B,A\}$ 不可满足，这与 $\Delta$ 有限可满足矛盾；

由归纳假设，${\scr I}\models\{B,C\}$，故 ${\scr I}\models A$

$A=B\vee C,A=B\rightarrow C$ 同理....
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/20/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%9101-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/17/%E7%94%A8haskell%E5%86%99brainfuck%E8%A7%A3%E9%87%8A%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/17/%E7%94%A8haskell%E5%86%99brainfuck%E8%A7%A3%E9%87%8A%E5%99%A8/" class="post-title-link" itemprop="url">用haskell写brainfuck解释器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-17 23:51:00" itemprop="dateCreated datePublished" datetime="2022-01-17T23:51:00+08:00">2022-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          最近在看 Learn you a haskell for great good，刚好看到IO。因为实在想不到去哪写haskell练手，于是就去codewars上面找水题刷了。

感觉给了我最大震撼的FP是scheme，给了我现代FP体验的是Coq（好多东西和haskell无缝衔接，除了记号方面的适应），现在到Haskell了最大的体会就是这玩意提供了很多抽象，这是极好的，因为有很多东西我在以前都没有想过可以这么看待，现在就觉得比较自然了。但是俺目前好像还没有找到啥用上这些抽象的地方，于是有点懵逼

于是就到了喜闻乐见的写解释器环节，仍然是写一个brainfuck解释器，不过因为本菜菜的IO还玩得不是很溜，于是就只写了一个没有输入、只有最后输出单个结果的阉割版，但是也足够说明很多问题了。

最爽的大概就是pattern match和lazy evaluation了，前者使得各种分支被简化，后者让图灵机里“无限长的纸带”非常容易就能实现。此外类似where这样的语法写起来也很舒服，有写定语从句的感觉。

丢个链接[就跑](https://git.nju.edu.cn/olahiuj/bf-hs/)，后面看完了haskell的IO大概会加上bf的IO的（一定不咕！）
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/17/%E7%94%A8haskell%E5%86%99brainfuck%E8%A7%A3%E9%87%8A%E5%99%A8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/11/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%BA%BA%E5%B9%B3%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/11/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%BA%BA%E5%B9%B3%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">大二上躺平经验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-11 02:17:00" itemprop="dateCreated datePublished" datetime="2022-01-11T02:17:00+08:00">2022-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          ## 大二上躺平经验

2021年的记忆都停留在了五六月份...现在不是很想回忆，但是那段时间确实又欣喜又自卑，随后的七八月一直在学校里过着昼夜颠倒的生活。再往后就没什么印象了，那之后也不怎么拍照，人是越活越不明白了



## 七八月

七月初的时候和辅导员申请全程留校，然后就来消息说广东解封了，于是连夜说服辅导员第二天回家，并且也确实回成了。

回家那天本来买的是下午的飞机，结果延误到傍晚，再接着就直接取消了——当天全禄口的航班都G了。于是当机立断买高铁票去常州坐飞机，然后成功在凌晨两点到了广州。回到家第二天就是社会实践，于是睡了两个小时就又出门了。现在想想也是太猛了

回来就开始集训，说是集训，其实因为禄口的事情就变成了网友开黑。一周四场，开始还改一改题目，后面就彻底佛了。八月初的时候买了一对音箱，在宿舍连夜看完了半泽直树、空我、W、迪迦和泽塔，然后就进了假面骑士的特摄大坑。

中途开始看软件分析的网课，前面还挺有意思，后面就是很具体的实现了。第一次写java，还专门找了本Head First看了一下恶补。然后还看了三章的龙书+80页的数理逻辑，不得不说英文书看起来确实很慢，只能是慢慢来了，毕竟也就是看着玩玩。

在八月的时候还买了一整箱的泡面和玉米肠，过上了一段不能说不糜烂的生活。同时还掌握了栏杆交易外卖的技能，唯一可惜的是没有在封校期间尝试过翻墙出门，不然就没啥遗憾的了。



后面的都不太记得了，咕咕咕



## 课程踩坑

还是挺多坑的，这学期好像要刷分也不容易，不过以后不打算跟着培养方案混了，也不用特别在乎本来要上的那些课吧，虽然本菜菜也不知道以后想干啥，还是很迷茫的o(╯□╰)o

### 近代史

娜娜是很有个性的老师，上课很有趣，值得一听，但是后面基本都是听同学做pre，也就比较无聊了

平时要交一次作业，小组做一次pre，有一次点名。最后考试不划重点（给了七个重大历史事件和某某重要人物讲话数据库）

然后考试非常赤鸡，大概六个名词解释，一个送分，一个要看书，还有一个是翻往年卷的截图记下来的，剩下的三个一个都没见过：意思是开考就没了15分

目前还没出分，不过我觉得已经无所谓了。像这种思政课，如果选不到红的话，随大流和大班一起上也不是最坏的选择——起码大家都差不多



### 体质健康与提升 3.85

老师人很好，第一次上体育课也有课间休息，最后一次课也可以不用去，不像别的课需要过去听理论

平时会讲一些健身小技巧，然后就是各种负担不大的趣味小训练，最后可以玩飞镖射箭，算是比较好玩的课了

平时要跑步打卡，不过我基本都摸了...

出分力，只能说体测实在太拉了（

### 密码学 4.0

每学期的痛苦面具，这学期就是它

课程说不上难，光听他讲还是蛮有意思的。但是题目都比较难。平时也没有花时间去看，更别说做题了。前半学期基本上看懂套路就可以考不错了，但是后期基本上在讲一些公钥密码的具体操作，而没有证明很多东西，但是考试又要考，所以就没怎么学懂....

平时的作业都是课本后面的习题，期中考试也是课本后习题的真子集。习题答案可能要找一找才能找到，不过找到了没有坏处，毕竟平时分全靠作业算

而且因为这门课必修，还不敢免，就没办法选矿院的ICS，从而只能去上课时阉割版的AI特供。不过从结果来看是差不多的，就没什么所谓了。

最后期末考开卷，但是题都不太会，有一道有原题的也没有抄对....只能说求放过了，我是真的没学懂



### 概率论 4.75

AI特供版概率论，大概上了浙大课本的一半。额外的还讲了一些集中不等式和组合计数的东西，不过都是一些套路

gw上课名言：“这个我不记得了，你们背下来就可以了。” 由此可见这门课程的考核难度

期末基本上都不是难题，平时作业也都比较好做，就是每周都写还要交电子稿就很麻烦，第一次很想要一个平板写作业，但是想想又还是算了，大概以后也不怎么会有要手写的作业了。

上课推导还算好，讲义也比较清楚，算是比较好的老师和课程了，拿高分很容易。



### 计算思维导论 4.0

SB课程。本来是计科的必修课，性质类似于导论课程，但是后面被下放成了公选课。为什么呢，相信大家心里都有数。

课程比较的无聊，对于大二的学生没有什么上的必要，也许给高中生听听还是可以的，毕竟也没什么干货。总共有三次作业，分别是py处理表格、py做KNN、py做词云三个有手就行的实验，没啥好说的，不过居然还要写实验报告。期末是开卷考试，可以带笔记本抄PPT，那就基本没什么了。不过竟然还出算法题.....这门课真的是通识课吗

不过这门课有两个学分，如果最后给分还行的话，水一水也不是不可以。



### 世界早期近代文明史 4.0

陈老师的课。陈老师是老先生，不会用手机，也没有课程群，更不上网课。上课会讲他的很多见闻，非常好玩。认真上课的基本是P社游戏玩家，去课堂上基本一抓一个准。平时也不点名、没有作业，最后是一次开卷考，唯一的难点大概在于需要记住考试时间+准备好课本，也就是第一次课和倒数第二次课一定要去，因为分别决定了你知不知道课本是啥、知不知道啥时候考试。

如果想要考高分，可以考前再认真翻翻课本，这样至少不用现场把整本书从头到尾看一遍——像我一样

结果最后分也不是特别好，可能是因为选这门课的文科生偏多？


### 数据结构 4.6

写着写着都快忘了我还有这门课了

老赵的豪华摸鱼套餐。本来是六学时的理论+实验课，硬生生变成3学时+1学时网课

只能说老赵特别会摸，基本上数据结构能讲的上学期都讲了，这学期就开始讲什么splay、左偏树、SA这些东西，讲法也基本就是教教做法，也没有特别的证明。属于是不要期待太多的课程体验，因此我开学就激情免修了。

平时的作业基本上都有答案可以参考，中途有一次读错需求手写压缩软件的代码作业，国庆节写了一整天....

期末仍然是老赵特色考卷，也就是出一些普及组-的题目来撑场子，没啥好说的，1h写完走人



### 软件分析 4.5

开学之后冲到了线下课程，感觉讲的没啥区别。实验多了两次，并且难度也不太一样，这次换上了船新版本Tai-e。实验和考试是五五开，最后考试也不是特别难，基本上熟读PPT就可以上80了。如果实验做的好，90+不是太难。

实验做起来主要是文档太长，代码要读很多才敢下手。有些API是上次用过的，下次再想不起来还得慢慢翻，这个也许是我IDE还用不溜的原因，是我的锅

值得一吹的是，7、8两次作业都是DDL当天写完的，事实证明并不是特别难，即使第7次因为一些错挂掉了不少分。



### 计算机系统基础 4.9

原谅我用全名，这门课算是这学期收获最大的课程了

我选的是AI特供版，一周只有3学时。本来就是冲着jyy去追星的，虽然最后他本人只来了一节课

理论课部分比较无聊，基本上就是把CSAPP又来了一次，在某些细节讲了很多没啥用的东西，又省掉了一些东西，就得到了这个版本的课本

比较值得一说的是实验课，PA的水准确实很高，自己写NEMU写NANOS-LITE的成就感也是满满的。只不过课程群的氛围有点怪，大家好像不太愿意实名讨论，也不敢提问，不愿意为了解决一些问题来放下所谓的尊严。而一些大佬也只是默默不说话，感觉缺少一点交流，只能自己默默做了

PA其实不需要选课也可以做，但是为了督促自己搞完还是选课比较好，这样不容易中途摸掉。

成绩的构成是60%PA+LAB，10%作业，30%期末。顺带一提，课本上很多错误，习题解答的题目反而是正确的...看不懂这种操作。期末考题量很大，而且到处都是坑，需要小心

顺便欢迎没选课的同学选课，欢迎选了课的同学来和本菜菜交流心得都是可以的~

### 阅读 4.5

这学期一口气选了两门阅读，还在亚马逊上买了两本书，结果愣是一点都没看（有一本为了期中交作业，连着看了三天）

讲一个好玩的事情，某门阅读要小组合作分工作展示，结果我一直都没有加群，中途还在思考“为啥还没有人牵头建群”这回事，结果到了展示前三天才发现原来群早就建好了，PPT也已经整完了.....于是我就成了划水摸鱼的可耻人。好在助教姐姐表示可以由我来做会议记录，然后换一点平时分，还贴心地给了我往年的参考，那就没啥可说的了。

感觉这种东西除非是真的很感兴趣（大一的两本），否则就不怎么想动....
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/11/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E8%BA%BA%E5%B9%B3%E7%BB%8F%E9%AA%8C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/11/PA4-%E9%99%84%E5%8A%A0%E5%85%B3%E5%8D%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jpwang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jjppp">
      <meta itemprop="description" content="Young, Simple & Naive">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | jjppp">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/11/PA4-%E9%99%84%E5%8A%A0%E5%85%B3%E5%8D%A1/" class="post-title-link" itemprop="url">PA4 附加关卡</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-11 01:05:00" itemprop="dateCreated datePublished" datetime="2022-01-11T01:05:00+08:00">2022-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 09:36:58" itemprop="dateModified" datetime="2022-06-19T09:36:58+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          ## 试验进度

我完成了全部必做内容，最后可以用F1、F2、F3分别玩nterm、pal和bird，默认初始打开的是nterm

## 思考题

### 为什么不叫"内核进程"?

可以发现，内核中所有正在执行的函数都共用一个虚拟地址空间——也就是内核地址空间，这是线程和进程最大的区别，因为每个进程都将会有自己的地址空间。

这也是为什么会说线程更轻，因为构造虚拟地址空间需要时间开销。



### 虚存管理中PIC的好处

可以只保存一份程序而将其映射到不同虚拟空间中。因为PIC可以被加载到任意地方执行，因此也就可以被任意映射到不同的虚拟地址空间中，这样就可以省去静态链接时耗费的共有代码所占用的空间。



### 理解分页细节

1. 为什么只有20位？因为一页是4KiB，因此就是12位。页表只需要指出页到页的映射关系，因此只需要说出这是2^20页中的哪一页就好了，所以只需要20位
2. 为什么要用物理地址？因为虚拟地址到物理地址需要翻译，并且非平凡的翻译需要依靠查阅页表来实现，所以如果CR3也用了虚拟地址，就会出现“访问自己的物理地址需要先知道自己的物理地址”的问题。当然这里的物理地址不是必须的，如果能够实现一个**比较简单的不依赖页表的**翻译（例如说把x映射到MAX-x这样的映射）也是可以的，这样仍然是虚拟地址，但是没有什么意义，也不够物理地址来的简单。
3. 为什么不采用一级页表？注意到一个页表项是32位，也就是4字节，所以一页只能存放2^10^=1024项。假设只有一级页表，那么就只能储存1024页，也就是只支持1024\*4KiB=4MiB的物理地址。而如果采用两级，就可以做到2^10^\*2^10^\*4KiB=4GiB的物理内存了。



### 空指针真的是"空"的吗?

不是，只是因为0在虚拟地址空间中没有映射/有较高的访问权限，所以在进行地址转换的时候会产生异常，异常处理程序则会杀死越权访问的进程（也就是产生了段错误）

解引用的时候：获得变量的值->访问0地址->mmu进行地址转换->在页表中找不到/没有对应权限->引发异常，进入异常处理程序->进程被杀死



### 内核映射的作用

回忆课本上的虚拟地址空间的布局图就可以发现，每个进程都包含了内核部分的地址映射（高地址的部分留给操作系统内核）

这是很好理解的，在用户程序请求系统调用服务的时候，需要陷入内核态执行内核的代码。假如没有这一段内核映射的复制，那么就需要在trap的时候进行地址空间的切换，这样的开销是很大的。



###  native的VME实现

可以看到用到了`hsearch_r`，也就是一个利用了hash函数实现的查找表。因为map实际上就是一个映射关系，因此用hash实现虚拟页地址到物理页地址的映射就能很自然的实现了。在完成翻译层面的map之后，还要调用mmap来把物理地址和虚拟地址联系起来



### 中断和用户进程初始化

可以

时钟中断的特点是：

1. 中断发生后，陷入前的处理器状态与返回后的处理器状态完全相同
2. 此时已经进入用户态，ksp有值，即使sp是0也可以正确保存上下文，从而使得1的性质成立
3. 所以无论在中断到来时有没有sp，都相当于没有中断，因此可以正常初始化



### 用户态和栈指针

只需要注意到用户虚拟地址空间和内核虚拟地址空间存在差异，并且内核栈必然不在用户地址空间内即可。因此如果栈指针在内核空间而不在用户空间，就说明当前有访问内核数据的权限，因此处于内核态；否则处于用户态。



### 如何在操作系统中实现fork()?

注意到状态机的“状态”由CPU+内存决定，而外部设备则不在考虑范围内

1. 复制地址空间的映射
2. 复制CPU状态



## 一些记录

12月1号就已经写完了PA3+Lab4+报告，实际上一直等到了1月6号才开始着手写PA4.2后面的内容，因为手册上明明白白写着“这是最难的Phase了”

记录几个重大bug吧



### STRACE的bug

我之前在nanos-lite的syscall中添加过一段用于识别系统调用号、并输出对应参数的调试代码，这样就可以在OS层面观察用户程序的一些行为：例如申请了多少内存、打开了哪些文件。而将调用号转变为字符串的过程我是用数组实现的（就是实现`Int->String`的函数）。对于后面添加的一些系统调用没有及时增加对应的映射，就导致会以空指针为参数调用`printf`，这样就会在`vsprintf_r`里面挂掉。

我发现这个问题是因为在打开STRACE后，程序crash的地点发生了变化，于是就开始观察测试代码，通过给测试代码打断点的方法定位crash的地方，最后发现是调用`gettimeofday`之后引发了问题，原因是我没有给`gettimeofday`的调用号分配对应的字符串



### loader的bug（1）

其实一共有两个，每个都是惊天地泣鬼神的bug（其实并不）

背景是这样的：在执行用户程序的时候，用户程序会通过`brk`系统调用来设置program break，以此向OS动态申请内存。我们的OS就需要通过`mm_brk`来动态申请物理页，然后把对应新的虚拟地址页映射到物理页上。

第一个bug是这么观察到的：在执行用户程序的时候，`mm_brk`会一直分配物理页直到物理页耗尽！通过STRACE可以发现它第一次就用一个非常大的参数调用了`brk`（大概是0x81.....），这就让nanos-lite拼了命也搞不出足够的内存（欲求不满啊）

问题出在哪里呢？通过ITRACE我也只能发现问题现场在`malloc_r`函数里。经过一番激烈的思想斗争，我就开始翻阅libc里面的`malloc`函数的具体实现。最后发现问题是这样的：`malloc`函数会通过一个全局变量来记录已经分配了多少空间，这个全局变量应该是`.bss`节的，出现这样的问题是因为我的loader没有正确的实现对`.bss`的处理——而在没有VME的时候是可以的。

回去看loader就会发现问题是什么了：虽然同样是PT_LOAD段，但是并不是所有的页都需要写入内容，只需要改一改就可以解决了。



### loader的bug（2）

第二个问题其实发生在很后面了，是我在写完了PA4.3之后尝试运行bird时发现的bug

背景是这样的：bird调用了库函数`hsearch`来进行一些快速的映射和查找，而在这个库里面有一个全局变量`__default_hash`，用来记录一个默认的hash函数选择。按照常理，用户的代码段应该是0x40...的一个地址，但是这个全局变量在`hsearch_r`函数里被load出来之后，再用`jal`命令跳转一下，就跑到了一个0x00...的一个地址。我百思不得其解，就开始怀疑自己的ldst写错了

中途我尝试在`BirdMain.cpp`中输出一下这个变量——做法是`extern ...`，然后直接在用户程序里`printf`，这样就得到了正确的结果，并且也可以正常玩bird

因为这样的调试可能改动了代码段和数据段，因此就开始用readelf命令观察前后两份二进制文件。在写出了不同段的地址和`__default_hash`的地址之后就可以发现：这个变量位于数据段的最后四个字节！如果观察一下错误的跳转地址就可以发现，只有最高位那个4神秘消失了！

于是就开始回头看loader，果然是loader写错了：我没有正确处理好最后一页的最后一个字节的读取问题，这样就刚好丢掉了`__default_hash`的最后一个字节，在小端机上就表现为最高位的4被吃掉了。

其实中途也怀疑过loader，不过当时想的是两个数据段相互重叠导致某些页被映射了两次，但是实际上段是不相交的，不存在这样的问题。



### mstatus.MIE的bug

在PA4.3的时候加入了时钟中断，并且引入了中断屏蔽的机制。也就是说，在产生一个中断/异常之后，我们需要屏蔽CPU的中断引脚（通过mstatus的某两个bit实现）防止出现中断的嵌套，例如防止在进行上下文切换时，时钟中断到来使得正在恢复的上下文丢失之类的情况。

结合PA3中启动新进程的做法：我们通过在栈上放置一个上下文，然后将栈指针移动到这个栈上来引用上下文，并通过一段汇编代码来实现上下文的恢复。这就使得我们需要在上下文中恰当地实现mstatus的功能。注意到恢复上下文的途中仍然不能响应中断，而必须等到`mret`指令执行完才能恢复响应，因此mstatus的实现就很重要了。具体的不多说，这里我写错了，就导致了这样的问题。并且关掉时钟中断后不会复发、每次出错现场不确定，属于比较难调的bug



### trap.S的bug

这里的bug似乎不太好直说，不然就没有乐趣~~痛苦~~了

`asm_trap`算是整个PA比较核心的部分了，并且对它的修改也需要比较清楚了解整个系统的工作原理，也是最容易出bug的地方

具体的不多说，大概可以这么check你的实现：

1. 对于非进程切换的trap，都有 进入状态==离开状态；
2. 对于所有的进程切换的trap，都可以在对应的`ecall`指令中通过log获得对应时刻的上下文信息，然后肉眼check是否正确恢复。

形式化地说，就是每个进程有一个颜色，一个切换A->B就是一个颜色为A的左括号和一个颜色为B的右括号，我们希望任意时刻同颜色的括号构成的子序列是匹配的（左右括号匹配当且仅当颜色相同且对应硬件上下文完全一样）

这样一旦发现了上下文不匹配的情况，就可以立刻发现了。这里可以通过两个简单的用户程序来回`yield`观察一些行为，然后debug



### kcontext的bug

原本的上下文是统一存放在栈上的（新进程和内核线程在内核栈上，而中断到来时的用户上下文则放在用户栈上），在PA4中我们改变了这一点，通过一通操作使得在进入`irq_handle`之前，上下文先被储存到内核栈上。然后从`irq_handle`返回之后，先从内核栈上恢复上下文，再把指针恢复到用户栈上（如果是用户程序的话）

与上面出现的bug不同，这里是产生一个新的上下文需要的东西，因此不好用`assert`，需要想清楚再下手

注意到手册给出的实现做出了一些变量的合并，因此需要在`kcontext`和`ucontext`中注意上下文结构的构造，使得在返回时不会出现栈指针乱飞的情况。不过查出来也很简单，只需要对着`trap.S`慢慢看就好了
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/11/PA4-%E9%99%84%E5%8A%A0%E5%85%B3%E5%8D%A1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jpwang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
