<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>jjppp | Blog of jjppp</title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">jjppp</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            数据结构 笔记1 搜索树
        </div>
        <div class="post-meta">
            2021-05-29
        </div>
    

    
    
    <div class="post-md">
        <p>感觉一下子进度快了很多，中间有一些需要记的，还有一些偏工业的，现在补一补。 内容全部来自《算法导论》，啃了一遍之后觉得这本书真是强啊，理论上说用这个入门就没必要看别的书了…..也许这就是本意吧 这波主要是树相关，后面可能会持续更新，看我有没有空吧….. 是写给自己看的，也许会有一点电波 ## 二叉搜索树(Binary Search Tree) 实际上是对链表和二分过程的结合。我们希望在保持二分性质的前提下支持快速插入和删除某些元素，这样的需求推动了BST的出现 ### 定义 严格的二叉搜索树定义如下： 1. 定义一个节点有`lch`,`rch`,`fa`,`key`这四个基础的指针，分别表示节点的左右孩子、父亲、键值(通常是我们所关心的数据)，还会有一些所谓卫星数据(也就是我们不太关心的但与节点相关数据) 2. 单个节点是BST 3. $T$是BST当且仅当$T$的左右子树都是BST，且左子树$T_L$中的`key`全部小于$T$的根的`key`，$T_R$的全部`key`大于$T$的根的`key` 这里实际上是简化了讨论存在重复键值的情况，即我们认为每个`key`是唯一的。 ### 操作 既然是数据结构就要有操作。BST支持经典的**增删查改**，还可以做第查找k大&#x2F;第k小 #### 查找&#x2F;修改 实际上就是在序列上二分 #### 前驱&#x2F;后继 这俩是对称的。 设要找$p$的前驱，就先找到$p$，再分两种情况： 1. $p$有左儿子，那么就是$p$左子树的最大值 2. $p$没有左儿子，那么$p$的前驱一定是$p$的某个祖先（why?），向上跳直到当前节点是父节点的右儿子就好了 #### 插入 实际上也是在序列上二分，然后用树的插入就好了 #### 删除 分三种情况，设要删掉$p$ 1. $p$是叶子，直接删掉就可以啦 2. $p$有一个孩子$q$，那么就删掉$p$，让$p$的父亲认$q$做新的儿子 3. $p$有两个孩子，那么就查找$p$的前驱(比他小的最大值)，交换二者`key`，问题规约为删除$q$。由$q$是$p$的前驱可知$q$没有右儿子(反证法就可以得到) 前两个都是简单的，第三个需要证明一下交换再删除的操作不改变BST的定义，也不太难 #### 第k大 做这个要维护一下每棵子树的大小，再用k去二分就好了。 ### 基本性质 1. size为$n$的BST的高度**最小**为$\log_2(n)$。直接由二叉树得出 2. BST的中序遍历是按`key`有序的。这个归纳即可得到 3. 高度为$h$的BST的单次查找、删除、插入复杂度都是$\Theta(h)$的 4. 随机数列生成的BST高度期望为$\log_2(n)$ ## B-树(B-Tree) 这里的“-”是连接符，不念“B减树” B树的本质是索引树。在计算机中，不同层级的储存之间的速度存在显著差异。通常大量的数据储存在外存（硬盘）中，内存只保留对数据的索引。这类问题的硬盘读写时间远大于CPU时间，因此我们主要关心前者。 ### 定义 1. 一个节点有`size`个键值(key value)，有`size+1`个儿子节点，同时记录父节点`parent` 2. 所有的键值按照顺序排放 3. 任意节点`x`的键值`key_i`，若`x`是`x.parent`的第`i`个孩子，则必有`x.parent.key_{i-1} #include #define rel(x) do { if (x !&#x3D; nullptr) delete x; x &#x3D; nullptr; } while (0) template class BTree; template void read( T &amp; ); template class BTreeNode { typedef BTreeNode Node; typedef std:: pair NodePos; public: BTreeNode( bool is_leaf &#x3D; false, Node *parent &#x3D; nullptr ): parent( parent ), is_leaf( is_leaf ), size(0 ) { for ( int i &#x3D; 0; i &lt;&#x3D; M; ++ i ) this-&gt;p[i] &#x3D; nullptr; for ( int i &#x3D; 0; i &lt; M; ++ i ) { this-&gt;keys[i] &#x3D; 0; } } bool isLeaf() { return this-&gt;is_leaf; } bool isRoot() { return this-&gt;parent &#x3D;&#x3D; nullptr; } bool isFull() { return this-&gt;size &#x3D;&#x3D; M; } &#x2F;&#x2F; return true if node is rich enough to delete a key bool isRich() { return this-&gt;size &gt; ( M &#x2F; 2 ); } bool isValid() { for ( int i &#x3D; 0; i &lt;&#x3D; size; ++ i ) { if ( p[i] &amp;&amp; p[i]-&gt;parent !&#x3D; this ) return false; } if ( size &lt; ( M &#x2F; 2 ) || size &gt; M ) return false; return true; } &#x2F;&#x2F; returns i if i is the first Node.keys[i] &gt;&#x3D; key, -1 if there’s no such key int findKey( const T_keys &amp;key ) { for ( int i &#x3D; 0; i &lt; this-&gt;size; ++ i ) { if ( key &lt;&#x3D; this-&gt;keys[i]) return i; } return this-&gt;size; } int findWhich( Node *x ) { for (int i &#x3D; 0; i &lt;&#x3D; size; ++ i) { if (p[i] &#x3D;&#x3D; x) return i; } return -1; } void insert_front( const T_keys &amp;key, Node *inp ) { for ( int i &#x3D; this-&gt;size; i &gt; 0; – i ) { this-&gt;keys[i] &#x3D; this-&gt;keys[i - 1]; this-&gt;p[i + 1] &#x3D; this-&gt;p[i]; } this-&gt;p[1] &#x3D; this-&gt;p[0]; this-&gt;p[0] &#x3D; inp; this-&gt;keys[0] &#x3D; key; if (inp !&#x3D; nullptr) { inp-&gt;parent &#x3D; this; } this-&gt;size ++; } void insert_back( const T_keys &amp;key, Node *inp ) { this-&gt;keys[size] &#x3D; key; this-&gt;p[++ size] &#x3D; inp; if (inp !&#x3D; nullptr) { inp-&gt;parent &#x3D; this; } } &#x2F;&#x2F; insert key &amp; data in leaf nodes void insert( const T_keys &amp;key, Node *inp &#x3D; nullptr ) { int pos &#x3D; this-&gt;findKey( key ); for ( int i &#x3D; this-&gt;size; i &gt; pos; – i ) { this-&gt;keys[i] &#x3D; this-&gt;keys[i - 1]; this-&gt;p[i + 1] &#x3D; this-&gt;p[i]; } this-&gt;keys[pos] &#x3D; key; this-&gt;p[pos + 1] &#x3D; inp; this-&gt;size ++; if (inp !&#x3D; nullptr) { inp-&gt;parent &#x3D; this; } } &#x2F;&#x2F; remote node( key, datum ) and set split nodes to be its children void insert_remote( const T_keys &amp;key, Node *lch, Node *rch ) { int pos &#x3D; this-&gt;findKey( key ); for ( int i &#x3D; this-&gt;size; i &gt; pos; – i ) { this-&gt;keys[i] &#x3D; this-&gt;keys[i - 1]; this-&gt;p[i + 1] &#x3D; this-&gt;p[i]; } this-&gt;keys[pos] &#x3D; key; this-&gt;p[pos] &#x3D; lch; this-&gt;p[pos + 1] &#x3D; rch; this-&gt;size ++; } void remove_front() { for (int i &#x3D; 0; i &lt;&#x3D; size; ++ i) { keys[i] &#x3D; keys[i + 1]; p[i] &#x3D; p[i + 1]; } size –; } void remove_back() { keys[size - 1] &#x3D; 0; p[size] &#x3D; nullptr; size–; } &#x2F;&#x2F; remove keys[pos] in leaf node void removeByPos(const int &amp;pos) { for (int i &#x3D; pos; i &lt; size; ++ i) { keys[i] &#x3D; keys[i + 1]; p[i] &#x3D; p[i + 1]; } keys[size] &#x3D; 0; p[size –] &#x3D; nullptr; } &#x2F;&#x2F; split node *this Node *split() { if ( !this-&gt;isFull() ) return nullptr; &#x2F;&#x2F; if this is root, then split this and set a new root if ( this-&gt;isRoot() ) { this-&gt;parent &#x3D; new Node( false, nullptr ); } Node *newNode &#x3D; new Node( this-&gt;isLeaf() , this-&gt;parent ); int mid &#x3D; M &#x2F; 2; T_keys mid_key &#x3D; this-&gt;keys[mid]; this-&gt;keys[mid] &#x3D; 0; this-&gt;parent-&gt;insert_remote( mid_key, this, newNode ); for ( int i &#x3D; mid + 1; i &lt; this-&gt;size; ++ i ) { newNode-&gt;keys[i - mid - 1] &#x3D; this-&gt;keys[i]; newNode-&gt;p[i - mid - 1] &#x3D; this-&gt;p[i]; if ( this-&gt;p[i] !&#x3D; nullptr ) this-&gt;p[i]-&gt;parent &#x3D; newNode; this-&gt;p[i] &#x3D; nullptr; this-&gt;keys[i] &#x3D; 0; } newNode-&gt;p[M &#x2F; 2] &#x3D; this-&gt;p[this-&gt;size]; if ( this-&gt;p[this-&gt;size] !&#x3D; nullptr ) this-&gt;p[this-&gt;size]-&gt;parent &#x3D; newNode; this-&gt;p[this-&gt;size] &#x3D; nullptr; this-&gt;size &#x3D; newNode-&gt;size &#x3D; M &#x2F; 2; return newNode; } NodePos minimum() { if ( p[0] &#x3D;&#x3D; nullptr ) return NodePos( this, 0 ); return p[0]-&gt;minimum(); } NodePos maximum( Node *x ) { if ( p[size] &#x3D;&#x3D; nullptr ) return NodePos( this, size ); return p[size]-&gt;minium(); } void mergeLeft( int pos, Node *&amp;right ) { keys[size] &#x3D; parent-&gt;keys[pos]; for (int i &#x3D; 0; i &lt; right-&gt;size; ++ i) { keys[size + i + 1] &#x3D; right-&gt;keys[i]; p[size + i + 1] &#x3D; right-&gt;p[i]; if (right-&gt;p[i] !&#x3D; nullptr) right-&gt;p[i]-&gt;parent &#x3D; this; right-&gt;keys[i] &#x3D; 0; right-&gt;p[i] &#x3D; nullptr; } size +&#x3D; 1 + right-&gt;size; p[size] &#x3D; right-&gt;p[right-&gt;size]; right-&gt;p[right-&gt;size] &#x3D; nullptr; if (p[size] !&#x3D; nullptr) p[size]-&gt;parent &#x3D; this; rel(right); parent-&gt;removeByPos(pos); } private: Node *p[M + 2], *parent; T_keys keys[M + 1]; bool is_leaf; &#x2F;&#x2F; the number of keys in a Node* int size; friend class BTree ; } ; template class BTree { typedef BTreeNode Node; typedef std:: pair NodePos; public: BTree() { this-&gt;root &#x3D; new Node( true, nullptr ); } NodePos find( const T_keys &amp;key ) { for ( Node *x &#x3D; root, *res &#x3D; nullptr; x !&#x3D; nullptr; ) { int pos &#x3D; x-&gt;findKey( key ); Node *next &#x3D; x-&gt;p[pos]; int next_key &#x3D; x-&gt;keys[pos]; res &#x3D; x-&gt;split(); if (x &#x3D;&#x3D; root &amp;&amp; res !&#x3D; nullptr) { root &#x3D; root-&gt;parent; } if ( next_key &#x3D;&#x3D; key ) { if (res &#x3D;&#x3D; nullptr) { return NodePos( x, pos ); } else { if ( pos &lt; (M &#x2F; 2) ) { return NodePos( x, pos ); } else if ( pos &gt; (M &#x2F; 2) ) { return NodePos( res, pos - (M &#x2F; 2) - 1 ); } else { return NodePos( x-&gt;parent, x-&gt;parent-&gt;findKey( next_key ) ); } } } else if ( x-&gt;isLeaf() ) { break; } x &#x3D; next; } return NodePos( nullptr, -1 ); } void insert( T_keys key ) { Node *x &#x3D; root, *res &#x3D; nullptr; while ( !x-&gt;isLeaf() ) { int pos &#x3D; x-&gt;findKey( key ); Node *next &#x3D; x-&gt;p[pos]; res &#x3D; x-&gt;split(); if ( x &#x3D;&#x3D; root &amp;&amp; res !&#x3D; nullptr ) { root &#x3D; root-&gt;parent; } x &#x3D; next; } int pos &#x3D; x-&gt;findKey( key ); res &#x3D; x-&gt;split(); if ( x &#x3D;&#x3D; root &amp;&amp; res !&#x3D; nullptr ) { root &#x3D; root-&gt;parent; } if ( res &#x3D;&#x3D; nullptr || pos &lt;&#x3D; ( M &#x2F; 2 ) ) { x-&gt;insert( key ); } else { res-&gt;insert( key ); } } void adjust(Node *x) { if ( x-&gt;isValid() ) return ; if ( x-&gt;isRoot() ) { if ( x-&gt;size &#x3D;&#x3D; 0 ) { root &#x3D; x-&gt;p[0]; rel(root-&gt;parent); } return ; } int pos &#x3D; x-&gt;parent-&gt;findWhich( x ); Node *big_brother &#x3D; x-&gt;parent-&gt;p[pos + 1]; Node *little_brother &#x3D; (pos &gt; 0) ? (x-&gt;parent-&gt;p[pos - 1]) : nullptr; if ( big_brother !&#x3D; nullptr &amp;&amp; big_brother-&gt;isRich() ) { x-&gt;insert_back( x-&gt;parent-&gt;keys[pos], big_brother-&gt;p[0] ); std:: swap( x-&gt;parent-&gt;keys[pos], big_brother-&gt;keys[0] ); big_brother-&gt;remove_front(); } else if ( little_brother !&#x3D; nullptr &amp;&amp; little_brother-&gt;isRich() ) { x-&gt;insert_front( x-&gt;parent-&gt;keys[pos - 1], little_brother-&gt;p[little_brother-&gt;size] ); std:: swap( x-&gt;parent-&gt;keys[pos - 1], little_brother-&gt;keys[little_brother-&gt;size - 1] ); little_brother-&gt;remove_back(); } else { &#x2F;&#x2F; neither brothers are rich, merge if ( big_brother !&#x3D; nullptr ) { std:: swap(x-&gt;parent-&gt;p[pos], x-&gt;parent-&gt;p[pos +1]); x-&gt;mergeLeft( pos, big_brother ); } else { x-&gt;parent-&gt;p[pos] &#x3D; little_brother; little_brother-&gt;mergeLeft( pos - 1, x ); x &#x3D; little_brother; } adjust(x-&gt;parent); } } void remove(NodePos p) { Node *x &#x3D; p.first; &#x2F;&#x2F; the position of x in its parent int pos &#x3D; p.second; if ( !x-&gt;isLeaf() ) { NodePos successor &#x3D; x-&gt;p[pos + 1]-&gt;minimum(); Node *sx &#x3D; successor.first; int spos &#x3D; successor.second; std:: swap( sx-&gt;keys[spos], x-&gt;keys[pos] ); remove( successor ); } else { bool x_isRich &#x3D; x-&gt;isRich(); x-&gt;removeByPos( pos ); if ( !x-&gt;isRoot() &amp;&amp; !x_isRich ) { adjust( x ); } } } void remove(T_keys key) { NodePos p &#x3D; find(key); remove( p ); } void preOrder() { myPreOrder( this-&gt;root ); } bool isValid() { return myIsValid( this-&gt;root ); } private: void myPreOrder( Node *x ) { if ( x &#x3D;&#x3D; nullptr ) return ; if ( x-&gt;isLeaf() ) { for ( int i &#x3D; 0; i &lt; x-&gt;size; ++ i ) { std:: cout &lt;&lt; x-&gt;keys[i] &lt;&lt; “ “; } return ; } for ( int i &#x3D; 0; i &lt;&#x3D; x-&gt;size; ++ i ) { myPreOrder( x-&gt;p[i] ); if ( i !&#x3D; x-&gt;size ) { std:: cout &lt;&lt; x-&gt;keys[i] &lt;&lt; “ “; } } } bool myIsValid( Node *x ) { bool flag &#x3D; x-&gt;isValid() | (x &#x3D;&#x3D; root); if ( x-&gt;isLeaf() ) return flag; for ( int i &#x3D; 0; i &lt; x-&gt;size; ++ i ) { if (x-&gt;p[i] &#x3D;&#x3D; nullptr || x-&gt;p[i]-&gt;parent !&#x3D; x) return false; flag &amp;&#x3D; myIsValid( x-&gt;p[i]); } return flag; } friend class BTreeNode ; Node *root; } ; template void read( T &amp;x ) { T v &#x3D; 1; x &#x3D; 0; char ch &#x3D; getchar(); for (; ch &lt; ‘0’ || ch &gt; ‘9’; v &#x3D; ( ch &#x3D;&#x3D; ‘-‘ ) ? -1 : v, ch &#x3D; getchar() ); for (; ch &lt;&#x3D; ‘9’ &amp;&amp; ch &gt;&#x3D; ‘0’; x &#x3D; x * 10 + ch - ‘0’, ch &#x3D; getchar() ); x *&#x3D; v; } int main( void ) { freopen(“data.in”,”r”,stdin ); freopen(“myp.out”,”w”,stdout ); BTree *T &#x3D; new BTree (); int n; for ( read(n); n –; ) { int opt, x; read( opt ); read( x ); switch ( opt ) { case 1: { T-&gt;insert( x ); break; } case 2: { T-&gt;remove( x ); break; } } T-&gt;preOrder(); std:: cout &lt;&lt; std:: endl; } return 0; } ``` ## 红黑树(RB-Tree) BST的一大问题就是对于单调的数据容易退化成链表，复杂度没有保证，因此就引入了平衡二叉树的概念。 之前写过splay写过treap写过scapegoat，但是真正工业级的平衡树还是红黑树用的多（why？） 红黑树实际上是一种特殊的B-树，也称为2-3-4树。从这个角度来看，就很好理解了。 ### 定义 红黑树是一棵二叉平衡搜索树(BST)，其满足： 1. 每个节点都有唯一的颜色：红r或黑b 2. 根节点是黑色的 3. 任意红色节点不相邻 4. 任意节点v为根的子树中的所有叶子到v的路径上黑色点数量都相同 ### 平衡分析 关键在于性质3和4的结合。考虑任意两个叶子，它们到根的路径上黑点数量相同，不妨记为$bh$ 因为不全为黑点，且红点不相邻，故$rh_1\leqslant bh\and rh_2\leqslant bh$，于是$|H_1-H_2|&#x3D;|(bh+rh_1)-(bh+rh_2)|&#x3D;|rh_1-rh_2|\leqslant bh$ 可知红黑树是弱平衡的（相比AVL） ### 操作 #### 查找 和一般的BST一样，红黑树的查找操作就是在树上二分 #### 插入 和一般的BST一样，红黑树的插入就是在树上查找，然后增加一个新的节点 不同之处在于我们的节点有颜色。在红黑树中规定新节点染成R，这样得到的新树满足条件4 然而可能出现新节点v和它的父亲fa都是R的情况，这种时候就需要修正操作 #### 插入修正染色 记新节点为x，其父亲为y，爷爷为z，爷爷的另一个儿子（伯父&#x2F;叔父）为w 显然有y为R，z为B（在加入x之前这是一个合法的红黑树） 1. 若y和w都是R，则将它们染成B，将z染成R，对z递归修正； 2. 若w是B，则先确保x是y的左儿子（否则旋转x，交换指向x和y的指针），再染y为B，染z为R，旋转y 可以发现，1操作等价于把一个B点的颜色给了两个R儿子，这样做不会使得$bh$发生变化 类似的2操作也不会使$bh$增大 #### 删除元素 好麻烦…..先吃饭</p>
<!-- more -->

    </div>

</div>

                <div class="footer">
    <span>Copyright © 2022 jjppp</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>